<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ahfhalotools.objects API documentation</title>
<meta name="description" content="A collection of objects used to store and analyse AHF data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ahfhalotools.objects</code></h1>
</header>
<section id="section-intro">
<p>A collection of objects used to store and analyse AHF data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A collection of objects used to store and analyse AHF data.
&#34;&#34;&#34;

import numpy as np
from . import analysis
import warnings

#number of columns in profile table
PROFILE_COLUMNS = 29

&#39;&#39;&#39;=========================================================&#39;&#39;&#39;
&#39;&#39;&#39;                       HALO CLASS                        &#39;&#39;&#39;
&#39;&#39;&#39;=========================================================&#39;&#39;&#39;

class Halo:
    &#34;&#34;&#34;
    Stores information about a single halo at a single point in time.

    Attributes
    ----------
    halodata : dict (str : ?)
        Dictionary of halo data quantities
    ID : int
        ID of halo
    z : float
        Redshift of halo
    age : float
        Age of halo in Gyr
    sigV : float
        3D velocity dispersion of halo in km/s
    Rvir : float
        Virial radius in kpc/h
    Xc : float
        x position of halo in kpc/h (comoving)
    Yc : float
        y position of halo in kpc/h (comoving)
    Zc : float
        z position of halo in kpc/h (comoving)
    pos : np.array ( float )
        3D position vector of halo in kpc/h (comoving)
        Equal to [Xc,Yc,Zc]
    vel : np.array ( float )
        3D velocity vector of halo in km/s
    mbp_offset : float
        Offset between most bound particle and halo centre in kpc/h
    com_offset : float
        Offset between centre-of-mass and halo centre in kpc/h
    Ekin : float
        Kinetic energy in Msol/h (km/s)^2
    Epot : float
        Potential energy in Msol/h (km/s)^2
    Qvir : float
        Virial ratio
        Equal to -Ekin/Epot
    profiles : 2D array of float
        Raw profile data
    rawhalodata : array of dtype float
        Raw halodata row

    Notes
    -----
    To fully initialise halo, one must manually add each profile row using
    Halo.addProfile()

    All named halo data attributes are also present in the halodata dictionary.

    To retreive valid halodata keys, one can call Halo.halodata.keys() on a
    Halo instance.

    To retrieve valid profile data keys, one can call Halo.getProfileQuantityDict()
    on a Halo instance.

    Raw profile data can be accessed using Halo.profiles, which contains a
    list of rows corresponding to rows in the .AHF_profiles file. This can be
    used to retrive profile data that does not have a defined function in the
    Halo class (e.g. to get vcirc, which is column 6 in .AHF_profiles, one can
    call Halo.profiles[:,5])
    &#34;&#34;&#34;
    def __init__(self, halodata, z):
        &#34;&#34;&#34;
        Initialises halo instance from row of halodata

        Parameters
        ----------
        halodata : array of float
            The row of halo data from the .AHF_halos file
        z : float
            The redshift of the snapshot the halo belongs to

        Notes
        -----
        To fully initialise halo, one must manually add each row of profile data
        using Halo.addProfile()
        &#34;&#34;&#34;
        halodata_columns = [&#39;ID&#39;, &#39;hostHalo&#39;, &#39;numSubStruct&#39;, &#39;Mvir&#39;, &#39;npart&#39;,
            &#39;Xc&#39;, &#39;Yc&#39;, &#39;Zc&#39;, &#39;VXc&#39;, &#39;VYc&#39;, &#39;VZc&#39;, &#39;Rvir&#39;, &#39;Rmax&#39;, &#39;r2&#39;,
            &#39;mbp_offset&#39;, &#39;com_offset&#39;, &#39;Vmax&#39;, &#39;v_esc&#39;, &#39;sigV&#39;, &#39;lambda&#39;,
            &#39;lambdaE&#39;, &#39;Lx&#39;, &#39;Ly&#39;, &#39;Lz&#39;, &#39;b&#39;, &#39;c&#39;, &#39;Eax&#39;, &#39;Eay&#39;, &#39;Eaz&#39;, &#39;Ebx&#39;,
            &#39;Eby&#39;, &#39;Ebz&#39;, &#39;Ecx&#39;, &#39;Ecy&#39;, &#39;Ecz&#39;, &#39;ovdens&#39;, &#39;nbins&#39;, &#39;fMhires&#39;,
            &#39;Ekin&#39;, &#39;Epot&#39;, &#39;SurfP&#39;, &#39;Phi0&#39;, &#39;cNFW&#39;, &#39;n_gas&#39;, &#39;M_gas&#39;,
            &#39;lambda_gas&#39;, &#39;lambdaE_gas&#39;, &#39;Lx_gas&#39;, &#39;Ly_gas&#39;, &#39;Lz_gas&#39;, &#39;b_gas&#39;,
            &#39;c_gas&#39;, &#39;Eax_gas&#39;, &#39;Eay_gas&#39;, &#39;Eaz_gas&#39;, &#39;Ebx_gas&#39;, &#39;Eby_gas&#39;,
            &#39;Ebz_gas&#39;, &#39;Ecx_gas&#39;, &#39;Ecy_gas&#39;, &#39;Ecz_gas&#39;, &#39;Ekin_gas&#39;, &#39;Epot_gas&#39;,
            &#39;n_star&#39;, &#39;M_star&#39;, &#39;lambda_star&#39;, &#39;lambdaE_star&#39;, &#39;Lx_star&#39;,
            &#39;Ly_star&#39;, &#39;Lz_star&#39;, &#39;b_star&#39;, &#39;c_star&#39;, &#39;Eax_star&#39;, &#39;Eay_star&#39;,
            &#39;Eaz_star&#39;, &#39;Ebx_star&#39;, &#39;Eby_star&#39;, &#39;Ebz_star&#39;, &#39;Ecx_star&#39;,
            &#39;Ecy_star&#39;, &#39;Ecz_star&#39;, &#39;Ekin_star&#39;, &#39;Epot_star&#39;, &#39;mean_z_gas&#39;, &#39;mean_z_star&#39;]
        self.halodata = dict()
        for i in range(len(halodata_columns)):
            colName = halodata_columns[i]
            self.halodata[colName] = halodata[i]

        self.ID = halodata[0]
        self.rawhalodata = halodata
        self.profiles = np.empty((0,PROFILE_COLUMNS))
        self.z = z
        self.halodata[&#39;z&#39;] = z
        #age is in Gyr
        self.age = analysis.tfromz(z)
        self.halodata[&#39;age&#39;] = self.age
        #sigV in km/sec
        self.sigV = halodata[18]
        #Rvir,Xc,Yc,Zc in kpc/h
        self.Rvir = halodata[11]
        self.Xc = halodata[5]
        self.Yc = halodata[6]
        self.Zc = halodata[7]
        self.pos = np.array([self.Xc,self.Yc,self.Zc])
        self.halodata[&#39;pos&#39;] = self.pos

        #velocity in km/s
        self.halodata[&#39;vel&#39;] = np.array([self.halodata[&#39;VXc&#39;], self.halodata[&#39;VYc&#39;], self.halodata[&#39;VZc&#39;]])
        self.vel = self.halodata[&#39;vel&#39;]
        #mbp_offset and com_offset in kpc/h
        self.mbp_offset = halodata[14]
        self.com_offset = halodata[15]

        #energy in M_odot/h (km/sec)^2
        self.Ekin = halodata[38]
        self.Epot = halodata[39]

        #Mass of halo in M_odot/h
        self.Mvir = halodata[3]

        #virial ratio dimensionless
        self.Qvir = -self.Ekin/self.Epot
        self.halodata[&#39;Qvir&#39;] = self.Qvir

    def addProfile(self, row):
        &#34;&#34;&#34;
        Used to add profile rows to the halo object while initialising

        Parameters
        ----------
        row : array of dtype float
            The data row from .AHF_profiles

        Notes
        -----
        Profiles should be added in *increasing* order of |radius|, input will
        not be sorted.
        &#34;&#34;&#34;
        self.profiles = np.append(self.profiles,[row],axis=0)

    def getProfileQuantityDict(self):
        &#34;&#34;&#34;
        Returns a dictionary of valid profile quantity keys, mapped to bound
        methods for the relevant quantity.

        Returns
        -------
        quantityDict : dict { quantity (str) : bound method }
        &#34;&#34;&#34;
        quantityDict = {&#39;M_in_r&#39; : self.M_in_r,
                        &#39;M_in_shell&#39; : self.M_in_shell,
                        &#39;gasM_in_r&#39; : self.gasM_in_r,
                        &#39;gasM_in_shell&#39; : self.gasM_in_shell,
                        &#39;volumes&#39; : self.volumes,
                        &#39;encDens&#39; : self.encDensities,
                        &#39;locDens&#39; : self.locDensities,
                        &#39;gasEncDens&#39; : self.gasencDensities,
                        &#39;gasLocDens&#39; : self.gaslocDensities,
                        &#39;u_gas&#39; : self.intEnergies,
                        &#39;T&#39; : self.temps,
                        &#39;starM_in_r&#39; : self.starM_in_r,
                        &#39;starM_in_shell&#39; : self.starM_in_shell,
                        &#39;starEncDens&#39; : self.starencDensities,
                        &#39;starLocDens&#39; : self.starlocDensities}
        return quantityDict

    def radii(self):
        &#34;&#34;&#34;
        Returns an array containing all of the radii of the profiles.
        Units of kpc/h

        Returns
        -------
        radii : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,0]

    def M_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the total mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        M_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,2]

    def M_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the total masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        M_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.M_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def gasM_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the gas mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        gasM_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,24]

    def gasM_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the gas masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        gasM_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.gasM_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def starM_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the stellar mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        starM_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,25]

    def starM_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the stellar masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        starM_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.starM_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def volumes(self):
        &#34;&#34;&#34;
        Returns an array containing the volumes of each spherical profile
        Units of kpc^3 / h^3

        Returns
        -------
        volumes : array of dtype float
        &#34;&#34;&#34;
        return abs((4/3)*np.pi*(self.radii()**3))

    def shellvolumes(self):
        &#34;&#34;&#34;
        Returns an array containing the volumes of each profile *shell* (ie
        the volume between the current radius and the previous radius)

        Returns
        -------
        shellvolumes : array of dtype float
        &#34;&#34;&#34;
        vols = self.volumes()
        shellvols = vols - np.append([0], vols[:-1])
        return shellvols

    def encDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed total densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.M_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def locDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local total densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.M_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes
        #return self.profiles[:,4]

    def gasencDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed gas densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.gasM_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def gaslocDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local gas densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.gasM_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes
        #return self.profiles[:,4]

    def starencDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed stellar densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.starM_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def starlocDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local stellar densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.starM_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes

    def intEnergies(self):
        &#34;&#34;&#34;
        Returns an array containing the internal gas energy for each profile.
        Units : ?(km/s)^2? - units not clear from AHF documentation

        Returns
        -------
        IE : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,26]

    def temps(self):
        &#34;&#34;&#34;
        Returns an array containing the temperatures of gas for each profile.
        Calculated from the gas internal energy.
        Units of K

        WARNING:
        It is currently unclear what the gas thermal energy column represents,
        and so results using this function may be highly unreliable.

        Returns
        -------
        temps : array of dtype float
        &#34;&#34;&#34;
        print(&#34;WARNING: Temperature function may be using incorrect units for calculation&#34;)
        return analysis.UtoT(self.intEnergies())
        #IE = self.intEnergies()
        #gasM_in_r = self.gasM_in_r() * apconst.M_sun.value
        #out = np.array([0.0]*len(gasM_in_r))
        #U = np.divide(IE,gasM_in_r,out=out,where=gasM_in_r!=0)
        #return analysis.UtoT(U)

&#39;&#39;&#39;=========================================================&#39;&#39;&#39;
&#39;&#39;&#39;                     SNAPSHOT CLASS                      &#39;&#39;&#39;
&#39;&#39;&#39;=========================================================&#39;&#39;&#39;

class Snapshot:
    &#34;&#34;&#34;
    Contains information about a single snapshot of a simulation.

    WARNING: Snapshot objects have limited functionality, and are essentially
    just used to write truncated .AHF_halos and .AHF_profiles files after
    specifying a haloLimit during initialisation. File truncation should however
    be done by the ahfhalotools.filetools.truncateFiles() method, as that allows
    for truncation of mtree and mtree_idx files.
    &#34;&#34;&#34;
    def __init__(self, snapNo, z, haloFile, profileFile, haloLimit = -1):
        &#34;&#34;&#34;
        Initialises the Snapshot instance.

        Parameters
        ----------
        snapNo : int
            The snapshot number
        z : float
            The redshift of the snapshot
        haloFile : str
            The path to the .AHF_halos file to read from
        profileFile : str
            The path to the .AHF_profiles file to read from
        haloLimit : int, optional
            Sets number of halos at which file reading terminates
        &#34;&#34;&#34;
        self.snapNo = snapNo
        self.z = z
        #age in Gyr
        self.age = analysis.tfromz(z)
        self.__haloFile__ = haloFile
        self.__profileFile__ = profileFile

        &#39;&#39;&#39;--- read in from files specified ---&#39;&#39;&#39;
        if haloLimit == -1:
            halorows = np.genfromtxt(haloFile)
            profilerows = np.genfromtxt(profileFile)
        else:
            halorows = np.genfromtxt(haloFile, max_rows = haloLimit)
            if halorows.ndim == 1:
                #make sure halorows is a 2D array (happens if numHalos = 1)
                halorows = np.array([halorows])

            numProfileRows = int(halorows[:,36].sum())
            profilerows = np.genfromtxt(profileFile, max_rows = numProfileRows)

        halos = []

        profileRowCounter = 0

        for rowIndex, halorow in enumerate(halorows):

            hostHalo = int(halorow[1])
            nbins = int(halorow[36])
            #if ((hostHalo % 1000000000000) &gt; haloLimit or hostHalo == 0) and\
            #    rowIndex &gt;= haloLimit:
            #    #halo is not a subhalo of a halo of interest, nor is a halo
            #    # of interest itself, so skip
            #    continue

            halo = Halo(halorow,z)
            prevRadius = -float(&#39;inf&#39;)

            #read in nbins lines from profiles file if halo is one of first
            # haloLimit halos
            if rowIndex &lt; haloLimit:
                for i in range(nbins):
                    assert(not (profilerows[profileRowCounter,0] &lt;= 0 and prevRadius &gt; 0))
                    #profile row is still for same halo
                    halo.addProfile(profilerows[profileRowCounter])

                    prevRadius = profilerows[profileRowCounter,0]
                    profileRowCounter += 1

            #loop has broken because next row to consider is for next halo

            halos.append(halo)

            if len(halos) == haloLimit:
                break

        self.halos = halos

    def writeFiles(self, filenamebase):
        &#34;&#34;&#34;
        Writes data saved in snapshot instance into new files with names
        filenamebase.AHF_halos and filenamebase.AHF_profiles

        Parameters
        ----------
        filenamebase : str
            The base name (including path) of the files to be outputted.
            Extensions will be added by the method.

        Notes
        -----
        This method can be used to truncate AHF_halos and AHF_profiles file in
        conjunction with setting a haloLimit during initialisation of the
        instance. File truncation should however be done using the
        ahfhalotools.filetools.truncateFiles() method.
        &#34;&#34;&#34;
        profileRows = []
        haloRows = []
        for halo in self.halos:
            haloRows.append(halo.rawhalodata)
            for profile in halo.profiles:
                profileRows.append(profile)
        np.savetxt(filenamebase+&#34;.AHF_profiles&#34;,profileRows)
        np.savetxt(filenamebase+&#34;.AHF_halos&#34;,haloRows)

    @staticmethod
    def loadFiles(snapNos,zs,filebase,profileExt=&#34;.AHF_profiles&#34;,haloExt=&#34;.AHF_halos&#34;,haloLimit=-1):
        &#34;&#34;&#34;
        Loads an array of snapshot instances from a file name format and a list
        of snap numbers and redshifts.

        Parameters
        ----------
        snapNos : list of int
            The snapshot numbers to load
        zs : list of float
            The redshifts corresponding to the snapshot numbers in snapNos
        filebase : str
            The format of the base file name. Should be formatted as such:
            &#34;GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}&#34;
            {snap:0=3d} is replaced with the snapshot number, including leading
            zeroes if number is less than 3 digits.
            z:.3f is replaces with the redshift, to three decimal places.
            Extensions are added on by the method
        profileExt : str, default = &#34;.AHF_profiles&#34;
            The file extension for the AHF_profiles files
        haloExt : str, default = &#34;.AHF_halos&#34;
            The file extension for the AHF_halos files
        haloLimit : int , optional
            The maximum number of halos to read before file reading stops.

        Returns
        -------
        snaps : array of dtype Snapshot
            An array of Snapshot objects corresponding to each of the snapshots
            specified in snapNos and zs parameters.
        &#34;&#34;&#34;
        snaps = []
        noFiles = len(zs)
        for i in range(noFiles):
            snaps.append(Snapshot(snapNos[i],zs[i], filebase.format(snap=snapNos[i],z=zs[i])+haloExt,
                                  filebase.format(snap=snapNos[i],z=zs[i])+profileExt,
                                  haloLimit = haloLimit))
            #print(&#34;Loading: {0}%&#34;.format(i/noFiles * 100))
        return np.array(snaps)

&#39;&#39;&#39;=========================================================&#39;&#39;&#39;
&#39;&#39;&#39;                     CLUSTER CLASS                       &#39;&#39;&#39;
&#39;&#39;&#39;=========================================================&#39;&#39;&#39;

class Cluster:
    &#34;&#34;&#34;
    Stores information about every halo in every snapshot in the cluster over time
    Designed for data produced by AMIGA&#39;s Halo Finder (AHF)

    Attributes
    ----------
    simName : str
        Specifies the name of the simulation used to create the cluster, if
        specified during initialisation
    clusterNum : int
        Specifies the number of the cluster that the object belongs to
        Defaults to 0 if not specified during initialisation
    &#34;&#34;&#34;
    def __init__(self, fileBaseName, snapNums, zs, profileExt=&#34;.AHF_profiles&#34;,
            haloExt=&#34;.AHF_halos&#34;,mtreeidxExt=&#34;.AHF_mtree_idx&#34;,
            mtreeExt=&#34;.AHF_mtree&#34;, haloLimit=np.inf, clusterNum = 0,
            simName = &#34;&#34;, skipmtree = False):
        &#34;&#34;&#34;
        Initialises the cluster object from .AHF_profiles and .AHF_halos files

        Parameters
        ----------
        fileBaseName : str
            Base name of files without extensions. Should be formatted like:
            GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}
        snapNums : list of ints
            List of snap numbers to load files from
        zs : list of floats
            List of redshifts corresponding to snap numbers in snapNums
        profileExt : str, default = &#34;.AHF_profiles&#34;
        haloExt : str, default = &#34;.AHF_halos&#34;
        mtreeidxExt : str, default = &#34;.AHF_mtree_idx&#34;
        mtreeExt : str, default = &#34;.AHF_mtree&#34;
        haloLimit : int, optional
            Specifies maximum number of halos to load into memory per snapshot
            (see Notes)
        clusterNum : int, optional
            Specifies the number of the cluster that the object belongs to
            Defaults to 0
        simName : str, optional
            Specifies the name of the simulation used to create the cluster
            Defaults to &#34;&#34;
        skipmtree : bool, optional
            Whether or not to skip trying to read the merger tree. If False and
            no mtree file is present, funcation will just print out a warning.
            Defaults to false

        Notes
        -----
        haloLimit specifies point at which file reading stops - as such since
        halos can change in order in files over time, a halo initially at the
        end of the file can be truncated off in earler snapshots, resulting in
        an inability to track it through time. It is therefore ideal to specify
        haloLimit as a number larger than the number of halos you intend to
        investigate.

        Note that haloLimit will not limit the number of halos read in from
        .AHF_halos files, as extra halos are included during file truncation
        if they are subhalos of the first n halos (where n is the size of
        truncation)

        Also note that the file format for mtree is NOT SUSSING-2013, this
        class reads files of format specified in the AHF documentation:
            http://popia.ft.uam.es/AHF/files/AHF.pdf (P190)
        &#34;&#34;&#34;
        #load in data
        assert(len(snapNums)==len(zs))

        self.simName = simName
        self.clusterNum = clusterNum

        #haloDict maps haloID -&gt; halo object
        self._haloDict = dict()
        self._fatherDict = dict()

        #self._progDict maps int haloID -&gt;  [[sharedPart, progenitorID, progenitorPart]]
        self._progDict = dict()

        #self._encHaloDict maps int hostHaloID - &gt; list (HaloLite)
        self._encHaloDict = dict()

        for i in range(len(snapNums)):
            snapNum = snapNums[i]
            z = zs[i]
            #get file names from base provided
            fileNameFmt = fileBaseName.format(snap=snapNum,z=z)
            haloFile = fileNameFmt + haloExt
            profileFile = fileNameFmt + profileExt
            mtreeidxFile = fileNameFmt + mtreeidxExt
            mtreeFile = fileNameFmt + mtreeExt

            #loading halo and profile data
            halorows = np.genfromtxt(haloFile)
            profilerows = np.genfromtxt(profileFile)

            #check if files are just 1 row and if so convert them to correct
            # data type (2D array)
            if halorows.ndim == 1:
                halorows = np.array([halorows])
            if profilerows.ndim == 1:
                profilerows = np.array([profilerows])

            profileRowCounter = 0
            haloCounter = 0

            for halorow in halorows:

                halo = Halo(halorow,z)
                prevRadius = -float(&#39;inf&#39;)

                #check that we have not already reached end of profiles file,
                # nor have we read the profiles of haloLimit halos
                if profileRowCounter &lt; len(profilerows) and haloCounter &lt; haloLimit:
                    #start reading profile rows
                    while not (profilerows[profileRowCounter,0] &lt;= 0 and prevRadius &gt; 0):
                        #profile row is still for same halo
                        halo.addProfile(profilerows[profileRowCounter])

                        prevRadius = profilerows[profileRowCounter,0]
                        profileRowCounter += 1

                        #break at end of file
                        if profileRowCounter == len(profilerows):
                            break
                    #while loop has broken because next row to consider is for next halo

                assert(halo.ID not in self._haloDict)
                self._haloDict[halo.ID] = halo
                haloCounter += 1

            #there is no mtree or mtree_idx for the lowest snapshot in a simulation
            # so we check if we are dealing with the lowest snapshot and if so
            # we don&#39;t try and load mtree or mtree_idx
            if snapNum == min(snapNums):
                continue
            #loading merge tree idx data
            #mtree_idx file is formatted as childID fatherID
            try:
                idxrows = np.genfromtxt(mtreeidxFile)
                #check if idxrows is 1 row and if so convert it to correct
                # data type (2D array)
                if idxrows.ndim == 1:
                    idxrows = np.array([idxrows])
            except IOError:
                print(&#34;WARNING: File {0} not found, relevant data cannot be loaded&#34;.format(mtreeidxFile))
                idxrows = []
            #fatherDict maps childID -&gt; fatherID (key is childID)
            rowCounter = 0
            for idxrow in idxrows:
                self._fatherDict[int(idxrow[0])] = int(idxrow[1])
                rowCounter += 1
                if rowCounter == haloLimit:
                    break

            #mtree format:
            #   HaloID(1)   HaloPart(2)  NumProgenitors(3)
            #      SharedPart(1)    HaloID(2)   HaloPart(3)
            #note: mtree includes the father
            if not skipmtree:
                try:
                    mtreerows = np.genfromtxt(mtreeFile)
                except IOError:
                    print(&#34;WARNING: File {0} not found, relevant data cannot be loaded&#34;.format(mtreeFile))
                    mtreerows = []
                lineIndex = 0
                fileLength = len(mtreerows)

                while lineIndex &lt; fileLength-1:
                    haloID, nPart, numProg = mtreerows[lineIndex,:]

                    progenitorList = []
                    #loop through progenitor lines
                    for i in range(lineIndex+1,lineIndex+int(numProg)+1):
                        sharedPart, progenitorID, prognPart = mtreerows[i,:]
                        progenitorList.append([int(sharedPart),int(progenitorID),int(prognPart)])

                    #add list of projenitor dictionaries to _progDict
                    self._progDict[haloID] = np.array(progenitorList)
                    #move line index to next child line
                    lineIndex += int(numProg) + 1


    def getHalo(self, haloID):
        &#34;&#34;&#34;
        Gets the Halo instance corresponding to the halo ID. If the ID is
        invalid, will return -1

        Parameters
        ----------
        haloID : int
            The full haloID of the halo
            e.g. 128000000000002, 102000000000023

        Returns
        -------
        halo : Halo object
        &#34;&#34;&#34;
        try:
            halo = self._haloDict[haloID]
        except KeyError:
            halo = -1
        return halo

    def getFatherOf(self, haloID):
        &#34;&#34;&#34;
        Returns the haloID of the father halo

        Parameters
        ----------
        haloID : int
            The full haloID of the halo
            e.g. 128000000000002, 102000000000023

        Returns
        -------
        fatherID : int
            The haloID of the father halo
            If no such father exists (either due to truncation or end of file),
            returns -1
        &#34;&#34;&#34;
        try:
            return self._fatherDict[haloID]
        except KeyError:
            #no father stored for halo, so will return -1
            return -1

    def getMergeTreeEntry(self, haloID):
        &#34;&#34;&#34;
        Returns merger tree entry for halo.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo

        Returns
        -------
        mtree_entry : array of 3-tuples
            Formatted as [[sharedPart, progenitorID, progenitorPart]]
            (Same format as .AHF_mtree entry)
        &#34;&#34;&#34;
        try:
            return self._progDict[haloID]
        except KeyError:
            #haloID is probably in earliest snapshot loaded
            return None

    def trackID(self, haloID):
        &#34;&#34;&#34;
        Takes a haloID and returns an array of haloIDs corresponding to
        the chain of father halos backwards in time
        &#34;&#34;&#34;
        fatherID = self.getFatherOf(haloID)
        if fatherID == -1:
            #end of chain, return just current haloID
            return [haloID]
        else:
            return self.trackID(fatherID) + [haloID]

    def trackHalo(self,haloID):
        &#34;&#34;&#34;
        Takes a haloID and returns an array of halos corresponding to
        the chain of father halos backwards in time. If there are gaps in
        stored halos, those halos will be skipped

        See Also
        --------
        Cluster.trackID()
        &#34;&#34;&#34;
        chainIDs = self.trackID(haloID)
        halos = []
        for id in chainIDs:
            halo = self.getHalo(id)
            if halo != -1: halos.append(halo)
        return halos

    def getHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Used to retrieve values of halo data from a specified halo

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Does not accept delta quantities

        Returns
        -------
        value
            The halo data value corresponding to quantity specified
        &#34;&#34;&#34;
        halo = self.getHalo(haloID)
        try:
            return halo.halodata[quantity]
        except KeyError as err:
            msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
                  &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
                  &#34;instance.&#34;.format(quantity)
            raise KeyError(msg) from err
        except AttributeError:
            #self.getHalo has returned -1, ie we do not have the halo specified
            #loaded into memory
            return -1

    def funcOfZHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns a piece of halo data as a function of redshift. To be used for
        quantities stored in the .AHF_halos file.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Returns time delta of quantities when key is preceded by &#34;delta&#34;,
            e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time

        See Also
        --------
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        if quantity.startswith(&#34;delta&#34;):
            #return delta value instead of normal value
            return self.funcOfZDeltaHaloData(haloID,quantity[5:])

        #for normal values:
        halos = self.trackHalo(haloID)
        zs = np.array([halo.z for halo in halos])
        values = None
        try:
            values = np.array([halo.halodata[quantity] for halo in halos])
        except KeyError as err:
            msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
                  &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
                  &#34;instance.&#34;.format(quantity)
            raise KeyError(msg) from err
        return zs, values

    def funcOfAgeHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns a piece of halo data as a function of age. To be used for
        quantities stored in the .AHF_halos file.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Returns time delta of quantities when key is preceded by &#34;delta&#34;,
            e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        zs, values = self.funcOfZHaloData(haloID,quantity)
        return analysis.tfromz(zs), values

    def funcOfZDeltaHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns the change (delta) in a piece of halo data as a function of
        redshift. To be used for quantities stored in the .AHF_halos file.

        Delta q at redshift z2 is calculated as q(z2)-q(z1) where z1 is the
        redshift of the previous snapshot. Note that this requires snapshots
        to have relatively even redshift spacing for delta quantities to be
        comparible over time.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;

        Returns
        -------
        zs : list of float
            The redshifts correspond to each of the values in deltaValues
        deltaValues : list of float
            The delta values of the quantity specified

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        if quantity.startswith(&#34;delta&#34;):
            quantity = quantity[5:]

        #get redshifts and values for non-delta quantity
        zs, values = self.funcOfZHaloData(haloID, quantity)

        #calculate delta values
        deltaValues = values[1:]-values[:-1]
        #take off highest redshift from zs (can&#39;t calculate delta quantity
        # without an older snapshot)
        zs = zs[1:]

        return zs, deltaValues

    def funcOfAgeDeltaHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns the change (delta) in a piece of halo data as a function of
        age in Gyr. To be used for quantities stored in the .AHF_halos file.

        Delta q at age t2 is calculated as q(t2)-q(t1) where t1 is the
        age of the previous snapshot. Note that this requires snapshots
        to have relatively even redshift spacing for delta quantities to be
        comparible over time.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;

        Returns
        -------
        ts : list of float
            The ages in Gyr correspond to each of the values in deltaValues
        deltaValues : list of float
            The delta values of the quantity specified

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        &#34;&#34;&#34;
        zs, deltaValues = self.funcOfZDeltaHaloData(haloID,quantity)
        return analysis.tfromz(zs), deltaValues

    def funcOfZProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns a radius-dependent quantity as a function of redshift,
        interpolated at the given radius. To be used for quantities stored
        in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the profile data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfAgeProfileData
        Cluster.funcOfZDeltaProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
            return self.funcOfZDeltaProfileData(haloID,quantity[5:],radius)
        halos = self.trackHalo(haloID)
        zs = np.array([halo.z for halo in halos])
        values = []
        for halo in halos:
            rs, rvals = self.funcOfRadiusProfileData(halo.ID,quantity)
            interp = np.interp(radius, rs, rvals)
            values.append(interp)
        values = np.array(values)
        return zs, values

    def funcOfAgeProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns a radius-dependent quantity as a function of age,
        interpolated at the given radius. To be used for quantities stored
        in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the profile data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfZDeltaProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        zs, values = self.funcOfZProfileData(haloID,quantity,radius)
        return analysis.tfromz(zs),values

    def funcOfZDeltaProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns the time delta of a radius-dependent quantity as a function of
        redshift, interpolated at the given radius.

        To be used for quantities stored in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in
            deltaValues
        deltaValues : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfAgeProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
            quantity = quantity[5:]

        #get redshifts and values for non-delta quantity
        zs, values = self.funcOfZProfileData(haloID, quantity, radius)

        #calculate delta values
        deltaValues = values[1:]-values[:-1]
        #take off highest redshift from zs (can&#39;t calculate delta quantity
        # without an older snapshot)
        zs = zs[1:]
        return zs, deltaValues

    def funcOfAgeDeltaProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns the time delta of a radius-dependent quantity as a function of
        age, interpolated at the given radius.

        To be used for quantities stored in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in
            deltaValues
        deltaValues : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfAgeProfileData
        Cluster.funcOfZDeltaProfileData
        &#34;&#34;&#34;
        zs, deltaValues = self.funcOfZDeltaProfileData(haloID, quantity, radius)
        ages = analysis.tfromz(zs)
        return ages, deltaValues

    def funcOfRandZProfileDataPoints(self, masterHaloID, quantity, removeZeroes = False):
        &#34;&#34;&#34;
        Returns three 1d arrays that correspond to the coordinates of points
        with x = radius, y = redshift, z = quantity

        Uses radii that appear in AHF_profiles for each snapshot. Output comes
        as triangular grid (see notes).

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the halo being investigated in the *oldest*
            snapshot of interest
        quantity : str
            The name or column index of the profile data piece to use
        removeZeroes : bool
            Whether or not to remove points where the z value is 0. Default = False

        Returns
        -------
        r : array of float
            Array of radii in kpc/h
        z : array of float
            Array of redshifts
        val : array of float
            Array of values

        Notes
        -----
        The values returned from this function form a triangular grid, ideal for
        plotting with using matplotlib.pyplot.triplot or
        matplotlib.pyplot.plot_trisurf
        The values in z and r will not form a 2D grid, as the radii for each
        bin changes from snapshot to snapshot.

        See Also
        --------
        matplotlib.pyplot.triplot :
            Draw a unstructured triangular grid as lines and/or markers.
        mpl_toolkits.mplot3d.axes3d.Axes3D.plot_trisurf :
            Plot a triangulated surface
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        rs = np.empty(0)
        zs = np.empty(0)
        vals = np.empty(0)
        for haloID in haloIDs:

            #add rows to grid
            rrow, valrow = self.funcOfRadiusProfileData(haloID, quantity)
            zrow = [self.getHalo(haloID).z]*len(rrow)
            rs = np.concatenate((rs,rrow))
            zs = np.concatenate((zs,zrow))
            vals = np.concatenate((vals,valrow))

        if removeZeroes:
            #search for 0s in vals
            indexes = np.argwhere(vals==0)
            vals = np.delete(vals, indexes)
            rs = np.delete(rs, indexes)
            zs = np.delete(zs, indexes)
        return rs,zs,vals


    def funcOfRadiusProfileData(self, haloID, quantity, removeZeroes = False):
        &#34;&#34;&#34;
        Returns the profile quantity as a function of radius at the redshift
        corresponding to the snapshot number specified in haloID

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        removeZeroes : bool, default = False
            If True will remove any entries where the value of {quantity} is 0

        Returns
        -------
        rs : array of float
            Array of radii that correspond to values in values
        values : array
            Array of values specified by quantity parameter as a function
            of radius
        &#34;&#34;&#34;
        halo = self.getHalo(haloID)
        rs = halo.radii()

        if type(quantity) == type(int()):
            #have passed an index rather than a string key
            values = halo.profiles[:,quantity]
        else:
            quantitydict = halo.getProfileQuantityDict()
            values = None
            try:
                values = quantitydict[quantity]()
            except KeyError as err:
                message = &#34;Invalid profile data quantity key {0}. To retrieve valid &#34;\
                          &#34;profile data keys, one can call &#34;\
                          &#34;Halo.getProfileQuantityDict() on a Halo instance, or use&#34;\
                          &#34; the quantity&#39;s column index (eg for Ly in column (10), &#34;\
                          &#34;can give quantity = 9)&#34;.format(quantity)
                raise KeyError(message) from err
        if removeZeroes:
            #search for 0s in vals
            indexes = np.argwhere(values==0)
            values = np.delete(values, indexes)
            rs = np.delete(rs, indexes)
        rs = np.array(rs)
        values = np.array(values)
        return rs, values

    def getMergeSize(self, haloID, scheme = &#34;halodata&#34;, fractional = True):
        &#34;&#34;&#34;
        Calculates the size of the merger that the halo experienced between
        snapshots.

        Parameters
        ----------
        haloID : int
            The halo ID of the halo being investigated, in the snapshot after
            the merge.
            (i.e. to get the size of the merger between snapshot 102 to 103, one
            would use the ID 10300000000000x)
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the returned size should be the fractional size
            (returned as a decimal), or the absolute size (returned as the
            number of particles).

        Returns
        -------
        size : number
            The size of the merger. If fractional is true, size will be a
            decimal float representing the fractional merger size, and if
            false, will be an integer number of particles.
            If the scheme is an mtree scheme, and the halo has no merger tree
            entry, will return -1.

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        validSchemes = [&#34;mtree-largest&#34;,&#34;mtree-sum&#34;,&#34;mtree-first&#34;,&#34;halodata&#34;]
        if scheme not in validSchemes:
            msg = &#34;Scheme &#39;{0}&#39; is not a valid scheme! Accepted values are: \n{1}&#34;.format(scheme,&#34;, &#34;.join(validSchemes))
            raise ValueError(msg)

        if scheme == &#34;mtree-largest&#34; or scheme == &#34;mtree-sum&#34; or scheme == &#34;mtree-first&#34;:
            #get merge tree entry
            mtreeEntry = self.getMergeTreeEntry(haloID)

            #if there is no merge tree entry for halo, return -1
            if type(mtreeEntry) == type(None):
                msg = &#34;Halo {0} has no merge tree entry! Returning -1&#34;.format(haloID)
                warnings.warn(msg, RuntimeWarning)
                return -1

            #get list of IDs of sub halos of father halo
            fatherID = self.getFatherOf(haloID)
            #assert(mtreeEntry[0,1]==fatherID)
            subHaloIDs = [halo.ID for halo in self.getEnclosedHalos(fatherID) if halo.hostHalo == fatherID]
            #go through merge tree entries and ignore any that are from
            # halos that were subhalos of the father halo
            #print(&#34;looking at halo {0}:&#34;.format(haloID))
            mergeSize = 0
            for mtreeRow in mtreeEntry[1:]:
                #(we exclude first row as that will be the father halo)
                progID = mtreeRow[1]
                if progID not in subHaloIDs:
                    #print(&#34;   non sub halo progenitor found: {0}&#34;.format(progID))
                    #print(&#34;   shared size is {0}&#34;.format(mtreeRow[0]))
                    #we have a progenitor that was not previously a subhalo
                    # therefore the particles introduced are new

                    #if using mtree-first we can stop here, if mtree-sum
                    # we keep going and add all of the non subhalo
                    # contributions, if mtree-largest we set mergeSize to
                    # the largest sharedPart we find
                    if scheme == &#34;mtree-first&#34;:
                        mergeSize = mtreeRow[0]
                        break
                    elif scheme == &#34;mtree-largest&#34;:
                        mergeSize = max(mergeSize,mtreeRow[0])
                    elif scheme == &#34;mtree-sum&#34;:
                        mergeSize += mtreeRow[0]

            #print(&#34;mergeSize is now {0}\n&#34;.format(mergeSize))

            if fractional:
                fatherSize = mtreeEntry[0,2]
                mergeSize /= fatherSize

            return mergeSize
        elif scheme == &#34;halodata&#34;:
            #scheme only relies on delta M and M from .AHF_halos file
            fatherID = self.getFatherOf(haloID)
            if fatherID == -1:
                return -1

            #calculate delta M
            fatherM = self.getHaloData(fatherID,&#34;Mvir&#34;)
            childM = self.getHaloData(haloID,&#34;Mvir&#34;)
            mergeSize = (childM-fatherM)

            #if fractional divide by father mass
            if fractional:
                mergeSize /= fatherM
            return mergeSize


    def getMergeZs(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
        &#34;&#34;&#34;
        Returns the red shifts at which halo experiences merger above specified
        threshold

        Parameters
        ----------
        haloIDtoTrack : int
            The full haloID of haloID to track - will track backwards through
            time
        threshold : float, default = 0.2
            The threshold for merge size
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        zs : array of floats
            The redshifts that correspond to the snapshots just after the merges
            occur
        sizes : array of floats
            The sizes of the mergers

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        zs = []
        sizes = []
        for haloID in self.trackID(haloIDtoTrack)[1:]:
            #get merge size
            mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)
            #check if merger is larger than threshold, if it is add redshift and
            # size to list to return
            if mergeSize &gt; threshold:
                zs.append(self.getHalo(haloID).z)
                sizes.append(mergeSize)
        return np.array(zs), np.array(sizes)

    def getMergeTimes(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
        &#34;&#34;&#34;
        Returns the ages at which halo experiences merger above specified
        threshold

        Parameters
        ----------
        haloIDtoTrack : int
            The full haloID of haloID to track - will track backwards through
            time
        threshold : float, default = 0.2
            The threshold for merge size
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        ages : array of floats
            The ages that correspond to the snapshots just after the merges
            occur
        sizes : array of floats
            The sizes of the mergers

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        zs, sizes = self.getMergeZs(haloIDtoTrack,threshold=threshold,scheme=scheme,fractional=fractional)
        return analysis.tfromz(zs), sizes

    def getLargestMergeZInRange(self, masterHaloID, minZ, maxZ, scheme=&#34;halodata&#34;, fractional = True):
        &#34;&#34;&#34;
        Returns the redshift of the largest merger in the range of redshifts specified

        Parameters
        ----------
        masterHaloID : int
            Full haloID of halo to track in time in most recent snapshot
        minZ : float
            Defines minimum redshift for search range (inc.)
        maxZ : float
            Defines maximum redshift for search range (inc.)
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        z : float
            The redshift at which the largest merger occurred in the range
            If the two largest mergers are of the same size will return redshift
            of earliest one.
            If there are no snapshots found with redshift inside range specified
            will be None
        largestMergeSize : int
            The size of the largest merge event found in range.
            If there are no snapshots found with redshift inside range specified
            will be 0
        &#34;&#34;&#34;
        if maxZ &lt; minZ:
            msg = &#34;Expected maxZ &gt;= minZ but got maxZ &lt; minZ!&#34;
            raise ValueError(msg)

        z = None
        largestMerge = 0
        #loop over chain of father halos, not including oldest snapshot
        # as we will not have data for its father&#39;s enclosed halos
        for haloID in self.trackID(masterHaloID)[1:]:
            #check if halo redshift is inside range specified, if not skip
            haloZ = self.getHalo(haloID).z
            if haloZ &lt; minZ or haloZ &gt; maxZ: continue

            #get merger size
            mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)

            if mergeSize &gt; largestMerge:
                z = haloZ
                largestMerge = mergeSize
        return z, largestMerge

    &#34;&#34;&#34;=============================&#34;&#34;&#34;
    &#34;&#34;&#34;   ENCLOSED HALO FUNCTIONS   &#34;&#34;&#34;
    &#34;&#34;&#34;=============================&#34;&#34;&#34;

    def generateEnclosedHaloFile(self,hostHaloID,haloFile,outputFile,useAHFSubHalos=False):
        &#34;&#34;&#34;
        Performs a search across all halos in haloFile as
        to whether they are contained within a sphere 2 times the virial radius
        of the host halo.
        Generates a file containing only the relevant information about only
        the halos that are enclosed within the host halo.

        Parameters
        ----------
        hostHaloID : int
        haloFile : string
        outputFile : string
        useAHFSubHalos : bool, default = False
            Specifies whether to use AHF sub halo detection instead of detection
            by position

        Notes
        -----
        (Unless useAHFSubHalos is True,)
        Does not use AHF&#39;s sub halo detection, due to how AHF defines subhalos
        (it is possible for an object to lie within a host halo and not be
        considered a sub halo if it is not within a common isodensity contour)

        See also
        --------
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        &#34;&#34;&#34;
        if useAHFSubHalos:
            raise NotImplementedError
        else:
            hostHalo = self.getHalo(hostHaloID)
            halorows = np.genfromtxt(haloFile)

            header = [&#34;ID(1)&#34;,&#34;hostHalo(2)&#34;,&#34;Xc(3)&#34;,&#34;Yc(4)&#34;,&#34;Zc(5)&#34;,&#34;VXc(6)&#34;,&#34;VYc(7)&#34;,&#34;VZc(8)&#34;]
            #the relevant indexes of the above quantities in the AHF_halos file
            quantityIndexes = [0,1,5,6,7,8,9,10]
            outputRows = np.empty((0,len(header)))
            for halorow in halorows:
                haloID = halorow[0]
                #check that the halo being considered isn&#39;t the host halo
                if haloID == hostHaloID: continue

                #check if the position of the halo satisfied criteria for being
                # enclosed
                x = halorow[5]
                y = halorow[6]
                z = halorow[7]

                #calculate distance to centre of hostHalo
                dist = np.sqrt((hostHalo.Xc-x)**2+(hostHalo.Yc-y)**2+(hostHalo.Zc-z)**2)
                if dist &lt; 2*hostHalo.Rvir:
                    #halo is enclosed by hostHalo
                    #we can add the relevant data to the output rows
                    outputRow = np.array([halorow[i] for i in quantityIndexes])
                    outputRows = np.vstack((outputRows,outputRow))

            #write output file
            np.savetxt(outputFile,outputRows,header=&#34;, &#34;.join(header))

    def generateEnclosedHaloFilesFromChain(self,masterHaloID,haloFiles,outputFileFmt,useAHFSubHalos=False):
        &#34;&#34;&#34;
        Generates an enclosed halo file for each halo in the chain of father halos
        of the master halo specifies.

        WARNING: May take a while to run

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the halo to track in the most recent snapshot
        haloFiles : list ( str )
            List of halo files to use, ordered in *ascending* snapshot order
        outputFileFmt : str
            Format of output file. Should contain a {haloID}, which will be
            replaced by the halo ID of the host halo the file refers to.
            e.g. &#34;GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;
        useAHFSubHalos : bool
            Specifies whether to use AHF sub halo detection instead of detection
            by position
        See also
        --------
        Cluster.generateEnclosedHaloFile()
        Cluster.loadEnclosedHaloFilesFromChain()
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        assert(len(haloIDs)==len(haloFiles))

        for i in range(len(haloIDs)):
            haloID = haloIDs[i]
            haloFile = haloFiles[i]
            outputFile = outputFileFmt.format(haloID=haloID)
            self.generateEnclosedHaloFile(haloID,haloFile,outputFile,useAHFSubHalos=useAHFSubHalos)


    def loadEnclosedHaloFile(self,hostHaloID,fileName):
        &#34;&#34;&#34;
        Loads data from an enclosed halo file (.BDP_enchalos) into the Cluster
        instance.

        Parameters
        ----------
        hostHaloID : int
            The full haloID of the host halo
        fileName : str

        Notes
        -----
        Will load subhalos in as HaloLite objects in an array accessable using
        Cluster.getEnclosedHalos(hostHaloID)

        See also
        --------
        Cluster.generateEnclosedHaloFile()
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.getEnclosedHalos()
        &#34;&#34;&#34;
        encHaloRows = np.genfromtxt(fileName)
        encHaloArray = []
        for encHaloRow in encHaloRows:
            halo = HaloLite(encHaloRow)
            encHaloArray.append(halo)

        self._encHaloDict[hostHaloID] = encHaloArray

    def loadEnclosedHaloFilesFromChain(self,masterHaloID,fileNameFmt):
        &#34;&#34;&#34;
        Loads data from enclosed halo files (.BDP_enchalos) into the Cluster
        instance, for each halo in the chain of father halos of the master halo

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the master halo in the most recent snapshot
        fileNameFmt : str
            The file name format of .BDP_enchalos file, with {haloID} as a
            placeholder for the haloID in the file name
            e.g. &#34;GX//GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;

        Notes
        -----
        Will load subhalos in as HaloLite objects in an array accessable using
        Cluster.getEnclosedHalos(hostHaloID)

        See also
        --------
        Cluster.getEnclosedHalos(hostHaloID)
        Cluster.loadEnclosedHaloFile()
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.generateEnclosedHaloFile()
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        for haloID in haloIDs:
            self.loadEnclosedHaloFile(haloID,fileNameFmt.format(haloID=haloID))

    def getEnclosedHalos(self,hostHaloID):
        &#34;&#34;&#34;
        Gives the halos enclosed by the host halo specified

        Parameters
        ----------
        hostHaloID : int

        Returns
        -------
        enclosedHalos : list ( HaloLite )

        Notes
        -----
        Enclosed halo data must be loaded in for the halo in advance using
        Cluster.loadEnclosedHaloFile

        See also
        --------
        Cluster.loadEnclosedHaloFile
        &#34;&#34;&#34;
        try:
            return self._encHaloDict[hostHaloID]
        except KeyError as err:
            msg = &#34;ERROR: Halo {0} does not have enclosed halos loaded into memory!\n&#34;\
                  &#34;Before using data on enclosed halos, data must be loaded using&#34;\
                  &#34;Cluster.loadEnclosedHaloFile() or Cluster.loadEnclosedHaloFilesFromChain()&#34;.format(hostHaloID)
            raise Exception(msg) from err

    def getRelVelocitiesOfEncHalos(self, hostHaloID):
        &#34;&#34;&#34;
        Takes the halo ID of the host halo and returns an array of velocities of
        enclosed halos relative to host halo in km/s

        Parameters
        ----------
        hostHaloID : int

        Returns
        -------
        velocities : array ( array( Vx, Vy, Vz ) )

        See also
        --------
        Cluster.getRelSpeedsOfEncHalos()
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        &#34;&#34;&#34;
        encHalos = self.getEnclosedHalos(hostHaloID)
        velocities = []
        hostHalo = self.getHalo(hostHaloID)
        for encHalo in encHalos:
            relV = encHalo.vel - hostHalo.vel
            velocities.append(relV)
        return np.array(velocities)

    def getRelSpeedsOfEncHalos(self, hostHaloID, normalizeBy=None):
        &#34;&#34;&#34;
        Takes the halo ID of the host halo and returns an array of speeds of
        enclosed halos relative to host halo in km/s

        Parameters
        ----------
        hostHaloID : int
        normalizeBy : str, optional
            Specifies a halo data quantity of the host halo to normalize
            speeds by

        Returns
        -------
        speeds : array ( float )

        See also
        --------
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        Cluster.getRelVelocitiesOfEncHalos()
        &#34;&#34;&#34;
        velocities = self.getRelVelocitiesOfEncHalos(hostHaloID)
        speeds = np.array([np.linalg.norm(v) for v in velocities])
        #normalise speeds if specified
        if normalizeBy:
            haloVal = self.getHaloData(hostHaloID,normalizeBy)
            speeds = speeds / haloVal
        return speeds

    def genpColorMeshRelSpeedEncHalos(self, masterHaloID, nbins=40,
                                      normalizeBy=None, minv=None, maxv=None,
                                      useDensity = False):
        &#34;&#34;&#34;
        Generates data for the velocity distribution of enclosed halos as a
        function of time, in a format suitable for plotting on a matplotlib
        pcolormesh.

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the host halo in the most recent snapshot
        nbins : int
            The number of bins (defines resolution in velocity axis)
        normalizeBy : str, optional
            Specifies a halo data quantity of the host halo to normalize
            speeds by
        minv : float, optional
            Specifies minimum speed of bins (ie position of lhs of plot)
        maxv : float, optional
            Specifies maximum speed of bins (ie position of rhs of plot)
        useDensity : bool, default = False
            Specifies whether to give each histogram&#39;s frequency as a decimal
            density rather than number frequency. Useful for preventing the
            flattening of color maps at higher redshift when many more objects
            are present in later snapshots

        Returns
        -------
        vv : numpy 2darray ( float )
            A 2D array of velocity bin edges that make up the x values of the
            meshgrid of the pcolormesh
        zz : numpy 2darray ( float )
            A 2D array of redshift bin edges that make up the y values of the
            meshgrid for the pcolormesh
        freq : numpy 2darray ( float )
            A 2D array of the frequencies of velocities within the bins.
            If vv and zz are N x M, freq will be N-1 x M-1 to fit with pcolormesh
            input format.

        Notes
        -----
        zz will be formatted such that the redshift of row i in freq corresponds
        to row i+1 of zz. This means that when plotting a pcolormesh, the z value
        a &#34;pixel&#34; corresponds to is the *edge* of the &#34;pixel&#34; on the side of
        *lowest* redshift.
        In other words, the highest redshift row of zz (the first row) does not
        correspond to the redshift of any loaded snapshots and exists only
        to specify the bounds of the highest redshift &#34;pixels&#34;

        See also
        --------
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        Cluster.getRelVelocitiesOfEncHalos()
        Cluster.getRelSpeedsOfEncHalos()
        matplotlib.axes.Axes.pcolormesh
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        #generate 2D array of speeds, where each row corresponds to each halo
        # in halo father chain
        speeds = []
        #will track minimum and maximum speeds as we go, to allow for the
        # histograms to have consistent ranges
        minspeed = +np.inf
        maxspeed = -np.inf
        for haloID in haloIDs:
            speedRow = self.getRelSpeedsOfEncHalos(haloID,normalizeBy=normalizeBy)
            speeds.append(speedRow)

            #update min and max
            minspeed = min(minspeed,speedRow.min())
            maxspeed = max(maxspeed,speedRow.max())

        #overwrite min and max speed with user input, if minv or maxv specified
        if minv: minspeed = minv
        if maxv: maxspeed = maxv

        #populate vv and freq with bin edges and frequencies respectively
        freq = []
        bin_edges = []

        for encSpeeds in speeds:
            #encSpeeds represents list of speeds of enclosed halos of specific
            # halo in chain
            hist, bin_edges = np.histogram(encSpeeds,bins=nbins,range=(minspeed,maxspeed),
                                           density=useDensity)
            freq.append(hist)
        #bin_edges should all be the same, as each histogram has same min, max,
        # and number of bins
        vv = [bin_edges]*(len(freq)+1)
        vv = np.array(vv)
        freq = np.array(freq)

        #populate zz
        zz = [[self.getHalo(haloID).z]*(nbins+1) for haloID in haloIDs]
        #zz is missing extra first row that specifies upper redshift bound of
        # highest redshift pixels, so we add an extra first row with higher
        # redshift
        upperZ = 2*zz[0][0]-zz[1][0]
        zz = [[upperZ]*(nbins+1)] + zz
        zz = np.array(zz)

        return vv, zz, freq



&#39;&#39;&#39;=========================================================&#39;&#39;&#39;
&#39;&#39;&#39;                     HaloLite CLASS                      &#39;&#39;&#39;
&#39;&#39;&#39;=========================================================&#39;&#39;&#39;

class HaloLite:
    &#34;&#34;&#34;
    A lightweight class to store only information relevant to velocity and
    position for a halo. Used in generating lists of enclosed haloes to save
    space in memory.

    Attributes
    ----------
    ID : int
        halo ID
    hostHalo : int
        ID of host halo under AHF subhalo scheme (may be 0 if useAHFSubHalos is
        False when generating enclosed halos files)
    Xc : float
        x coordinate of halo in kpc/h comoving coords
    Yc : float
        y coordinate of halo in kpc/h comoving coords
    Zc : float
        z coordinate of halo in kpc/h comoving coords
    VXc : float
        x component of peculiar/bulk velocity in km/s
    VYc : float
        y component of peculiar/bulk velocity in km/s
    VZc : float
        z component of peculiar/bulk velocity in km/s
    pos : array (Xc , Yc , Zc)
        Array representing position. Equal to [Xc,Yc,Zc]
    vel : array (VXc , VYc , VZc)
        Array representing peculiar/bulk veclotiy. Equal to [VXc,VYc,VZc]

    See also
    --------
    Cluster.generateEnclosedHaloFile()
    Cluster.loadEnclosedHaloFile()
    Cluster.getEnclosedHalos()
    &#34;&#34;&#34;
    def __init__(self,encHaloRow):
        &#34;&#34;&#34;
        Initialises HaloLite object from row of enclosed halo data

        Parameters
        ----------
        encHaloRow : list
            Row should be formatted as:
            # ID(1), hostHalo(2), Xc(3), Yc(4), Zc(5), VXc(6), VYc(7), VZc(8)
            (As generated from Cluster.generateEnclosedHaloFile)
        &#34;&#34;&#34;
        #encHaloRow formatted as:
        # ID(1), hostHalo(2), Xc(3), Yc(4), Zc(5), VXc(6), VYc(7), VZc(8)
        self.ID = int(encHaloRow[0])
        self.hostHalo = int(encHaloRow[1])
        self.Xc = encHaloRow[2]
        self.Yc = encHaloRow[3]
        self.Zc = encHaloRow[4]
        self.VXc = encHaloRow[5]
        self.VYc = encHaloRow[6]
        self.VZc = encHaloRow[7]
        self.pos = np.array([self.Xc,self.Yc,self.Zc])
        self.vel = np.array([self.VXc,self.VYc,self.VZc])</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ahfhalotools.objects.PROFILE_COLUMNS"><code class="name">var <span class="ident">PROFILE_COLUMNS</span></code></dt>
<dd>
<div class="desc"><p>=========================================================</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ahfhalotools.objects.Cluster"><code class="flex name class">
<span>class <span class="ident">Cluster</span></span>
<span>(</span><span>fileBaseName, snapNums, zs, profileExt='.AHF_profiles', haloExt='.AHF_halos', mtreeidxExt='.AHF_mtree_idx', mtreeExt='.AHF_mtree', haloLimit=inf, clusterNum=0, simName='', skipmtree=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores information about every halo in every snapshot in the cluster over time
Designed for data produced by AMIGA's Halo Finder (AHF)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>simName</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the name of the simulation used to create the cluster, if
specified during initialisation</dd>
<dt><strong><code>clusterNum</code></strong> :&ensp;<code>int</code></dt>
<dd>Specifies the number of the cluster that the object belongs to
Defaults to 0 if not specified during initialisation</dd>
</dl>
<p>Initialises the cluster object from .AHF_profiles and .AHF_halos files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fileBaseName</code></strong> :&ensp;<code>str</code></dt>
<dd>Base name of files without extensions. Should be formatted like:
GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}</dd>
<dt><strong><code>snapNums</code></strong> :&ensp;<code>list</code> of <code>ints</code></dt>
<dd>List of snap numbers to load files from</dd>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>floats</code></dt>
<dd>List of redshifts corresponding to snap numbers in snapNums</dd>
<dt><strong><code>profileExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_profiles"</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>haloExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_halos"</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>mtreeidxExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_mtree_idx"</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>mtreeExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_mtree"</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>haloLimit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Specifies maximum number of halos to load into memory per snapshot
(see Notes)</dd>
<dt><strong><code>clusterNum</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Specifies the number of the cluster that the object belongs to
Defaults to 0</dd>
<dt><strong><code>simName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the name of the simulation used to create the cluster
Defaults to ""</dd>
<dt><strong><code>skipmtree</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to skip trying to read the merger tree. If False and
no mtree file is present, funcation will just print out a warning.
Defaults to false</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>haloLimit specifies point at which file reading stops - as such since
halos can change in order in files over time, a halo initially at the
end of the file can be truncated off in earler snapshots, resulting in
an inability to track it through time. It is therefore ideal to specify
haloLimit as a number larger than the number of halos you intend to
investigate.</p>
<p>Note that haloLimit will not limit the number of halos read in from
.AHF_halos files, as extra halos are included during file truncation
if they are subhalos of the first n halos (where n is the size of
truncation)</p>
<p>Also note that the file format for mtree is NOT SUSSING-2013, this
class reads files of format specified in the AHF documentation:
<a href="http://popia.ft.uam.es/AHF/files/AHF.pdf">http://popia.ft.uam.es/AHF/files/AHF.pdf</a> (P190)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cluster:
    &#34;&#34;&#34;
    Stores information about every halo in every snapshot in the cluster over time
    Designed for data produced by AMIGA&#39;s Halo Finder (AHF)

    Attributes
    ----------
    simName : str
        Specifies the name of the simulation used to create the cluster, if
        specified during initialisation
    clusterNum : int
        Specifies the number of the cluster that the object belongs to
        Defaults to 0 if not specified during initialisation
    &#34;&#34;&#34;
    def __init__(self, fileBaseName, snapNums, zs, profileExt=&#34;.AHF_profiles&#34;,
            haloExt=&#34;.AHF_halos&#34;,mtreeidxExt=&#34;.AHF_mtree_idx&#34;,
            mtreeExt=&#34;.AHF_mtree&#34;, haloLimit=np.inf, clusterNum = 0,
            simName = &#34;&#34;, skipmtree = False):
        &#34;&#34;&#34;
        Initialises the cluster object from .AHF_profiles and .AHF_halos files

        Parameters
        ----------
        fileBaseName : str
            Base name of files without extensions. Should be formatted like:
            GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}
        snapNums : list of ints
            List of snap numbers to load files from
        zs : list of floats
            List of redshifts corresponding to snap numbers in snapNums
        profileExt : str, default = &#34;.AHF_profiles&#34;
        haloExt : str, default = &#34;.AHF_halos&#34;
        mtreeidxExt : str, default = &#34;.AHF_mtree_idx&#34;
        mtreeExt : str, default = &#34;.AHF_mtree&#34;
        haloLimit : int, optional
            Specifies maximum number of halos to load into memory per snapshot
            (see Notes)
        clusterNum : int, optional
            Specifies the number of the cluster that the object belongs to
            Defaults to 0
        simName : str, optional
            Specifies the name of the simulation used to create the cluster
            Defaults to &#34;&#34;
        skipmtree : bool, optional
            Whether or not to skip trying to read the merger tree. If False and
            no mtree file is present, funcation will just print out a warning.
            Defaults to false

        Notes
        -----
        haloLimit specifies point at which file reading stops - as such since
        halos can change in order in files over time, a halo initially at the
        end of the file can be truncated off in earler snapshots, resulting in
        an inability to track it through time. It is therefore ideal to specify
        haloLimit as a number larger than the number of halos you intend to
        investigate.

        Note that haloLimit will not limit the number of halos read in from
        .AHF_halos files, as extra halos are included during file truncation
        if they are subhalos of the first n halos (where n is the size of
        truncation)

        Also note that the file format for mtree is NOT SUSSING-2013, this
        class reads files of format specified in the AHF documentation:
            http://popia.ft.uam.es/AHF/files/AHF.pdf (P190)
        &#34;&#34;&#34;
        #load in data
        assert(len(snapNums)==len(zs))

        self.simName = simName
        self.clusterNum = clusterNum

        #haloDict maps haloID -&gt; halo object
        self._haloDict = dict()
        self._fatherDict = dict()

        #self._progDict maps int haloID -&gt;  [[sharedPart, progenitorID, progenitorPart]]
        self._progDict = dict()

        #self._encHaloDict maps int hostHaloID - &gt; list (HaloLite)
        self._encHaloDict = dict()

        for i in range(len(snapNums)):
            snapNum = snapNums[i]
            z = zs[i]
            #get file names from base provided
            fileNameFmt = fileBaseName.format(snap=snapNum,z=z)
            haloFile = fileNameFmt + haloExt
            profileFile = fileNameFmt + profileExt
            mtreeidxFile = fileNameFmt + mtreeidxExt
            mtreeFile = fileNameFmt + mtreeExt

            #loading halo and profile data
            halorows = np.genfromtxt(haloFile)
            profilerows = np.genfromtxt(profileFile)

            #check if files are just 1 row and if so convert them to correct
            # data type (2D array)
            if halorows.ndim == 1:
                halorows = np.array([halorows])
            if profilerows.ndim == 1:
                profilerows = np.array([profilerows])

            profileRowCounter = 0
            haloCounter = 0

            for halorow in halorows:

                halo = Halo(halorow,z)
                prevRadius = -float(&#39;inf&#39;)

                #check that we have not already reached end of profiles file,
                # nor have we read the profiles of haloLimit halos
                if profileRowCounter &lt; len(profilerows) and haloCounter &lt; haloLimit:
                    #start reading profile rows
                    while not (profilerows[profileRowCounter,0] &lt;= 0 and prevRadius &gt; 0):
                        #profile row is still for same halo
                        halo.addProfile(profilerows[profileRowCounter])

                        prevRadius = profilerows[profileRowCounter,0]
                        profileRowCounter += 1

                        #break at end of file
                        if profileRowCounter == len(profilerows):
                            break
                    #while loop has broken because next row to consider is for next halo

                assert(halo.ID not in self._haloDict)
                self._haloDict[halo.ID] = halo
                haloCounter += 1

            #there is no mtree or mtree_idx for the lowest snapshot in a simulation
            # so we check if we are dealing with the lowest snapshot and if so
            # we don&#39;t try and load mtree or mtree_idx
            if snapNum == min(snapNums):
                continue
            #loading merge tree idx data
            #mtree_idx file is formatted as childID fatherID
            try:
                idxrows = np.genfromtxt(mtreeidxFile)
                #check if idxrows is 1 row and if so convert it to correct
                # data type (2D array)
                if idxrows.ndim == 1:
                    idxrows = np.array([idxrows])
            except IOError:
                print(&#34;WARNING: File {0} not found, relevant data cannot be loaded&#34;.format(mtreeidxFile))
                idxrows = []
            #fatherDict maps childID -&gt; fatherID (key is childID)
            rowCounter = 0
            for idxrow in idxrows:
                self._fatherDict[int(idxrow[0])] = int(idxrow[1])
                rowCounter += 1
                if rowCounter == haloLimit:
                    break

            #mtree format:
            #   HaloID(1)   HaloPart(2)  NumProgenitors(3)
            #      SharedPart(1)    HaloID(2)   HaloPart(3)
            #note: mtree includes the father
            if not skipmtree:
                try:
                    mtreerows = np.genfromtxt(mtreeFile)
                except IOError:
                    print(&#34;WARNING: File {0} not found, relevant data cannot be loaded&#34;.format(mtreeFile))
                    mtreerows = []
                lineIndex = 0
                fileLength = len(mtreerows)

                while lineIndex &lt; fileLength-1:
                    haloID, nPart, numProg = mtreerows[lineIndex,:]

                    progenitorList = []
                    #loop through progenitor lines
                    for i in range(lineIndex+1,lineIndex+int(numProg)+1):
                        sharedPart, progenitorID, prognPart = mtreerows[i,:]
                        progenitorList.append([int(sharedPart),int(progenitorID),int(prognPart)])

                    #add list of projenitor dictionaries to _progDict
                    self._progDict[haloID] = np.array(progenitorList)
                    #move line index to next child line
                    lineIndex += int(numProg) + 1


    def getHalo(self, haloID):
        &#34;&#34;&#34;
        Gets the Halo instance corresponding to the halo ID. If the ID is
        invalid, will return -1

        Parameters
        ----------
        haloID : int
            The full haloID of the halo
            e.g. 128000000000002, 102000000000023

        Returns
        -------
        halo : Halo object
        &#34;&#34;&#34;
        try:
            halo = self._haloDict[haloID]
        except KeyError:
            halo = -1
        return halo

    def getFatherOf(self, haloID):
        &#34;&#34;&#34;
        Returns the haloID of the father halo

        Parameters
        ----------
        haloID : int
            The full haloID of the halo
            e.g. 128000000000002, 102000000000023

        Returns
        -------
        fatherID : int
            The haloID of the father halo
            If no such father exists (either due to truncation or end of file),
            returns -1
        &#34;&#34;&#34;
        try:
            return self._fatherDict[haloID]
        except KeyError:
            #no father stored for halo, so will return -1
            return -1

    def getMergeTreeEntry(self, haloID):
        &#34;&#34;&#34;
        Returns merger tree entry for halo.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo

        Returns
        -------
        mtree_entry : array of 3-tuples
            Formatted as [[sharedPart, progenitorID, progenitorPart]]
            (Same format as .AHF_mtree entry)
        &#34;&#34;&#34;
        try:
            return self._progDict[haloID]
        except KeyError:
            #haloID is probably in earliest snapshot loaded
            return None

    def trackID(self, haloID):
        &#34;&#34;&#34;
        Takes a haloID and returns an array of haloIDs corresponding to
        the chain of father halos backwards in time
        &#34;&#34;&#34;
        fatherID = self.getFatherOf(haloID)
        if fatherID == -1:
            #end of chain, return just current haloID
            return [haloID]
        else:
            return self.trackID(fatherID) + [haloID]

    def trackHalo(self,haloID):
        &#34;&#34;&#34;
        Takes a haloID and returns an array of halos corresponding to
        the chain of father halos backwards in time. If there are gaps in
        stored halos, those halos will be skipped

        See Also
        --------
        Cluster.trackID()
        &#34;&#34;&#34;
        chainIDs = self.trackID(haloID)
        halos = []
        for id in chainIDs:
            halo = self.getHalo(id)
            if halo != -1: halos.append(halo)
        return halos

    def getHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Used to retrieve values of halo data from a specified halo

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Does not accept delta quantities

        Returns
        -------
        value
            The halo data value corresponding to quantity specified
        &#34;&#34;&#34;
        halo = self.getHalo(haloID)
        try:
            return halo.halodata[quantity]
        except KeyError as err:
            msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
                  &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
                  &#34;instance.&#34;.format(quantity)
            raise KeyError(msg) from err
        except AttributeError:
            #self.getHalo has returned -1, ie we do not have the halo specified
            #loaded into memory
            return -1

    def funcOfZHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns a piece of halo data as a function of redshift. To be used for
        quantities stored in the .AHF_halos file.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Returns time delta of quantities when key is preceded by &#34;delta&#34;,
            e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time

        See Also
        --------
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        if quantity.startswith(&#34;delta&#34;):
            #return delta value instead of normal value
            return self.funcOfZDeltaHaloData(haloID,quantity[5:])

        #for normal values:
        halos = self.trackHalo(haloID)
        zs = np.array([halo.z for halo in halos])
        values = None
        try:
            values = np.array([halo.halodata[quantity] for halo in halos])
        except KeyError as err:
            msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
                  &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
                  &#34;instance.&#34;.format(quantity)
            raise KeyError(msg) from err
        return zs, values

    def funcOfAgeHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns a piece of halo data as a function of age. To be used for
        quantities stored in the .AHF_halos file.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Returns time delta of quantities when key is preceded by &#34;delta&#34;,
            e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        zs, values = self.funcOfZHaloData(haloID,quantity)
        return analysis.tfromz(zs), values

    def funcOfZDeltaHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns the change (delta) in a piece of halo data as a function of
        redshift. To be used for quantities stored in the .AHF_halos file.

        Delta q at redshift z2 is calculated as q(z2)-q(z1) where z1 is the
        redshift of the previous snapshot. Note that this requires snapshots
        to have relatively even redshift spacing for delta quantities to be
        comparible over time.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;

        Returns
        -------
        zs : list of float
            The redshifts correspond to each of the values in deltaValues
        deltaValues : list of float
            The delta values of the quantity specified

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfAgeDeltaHaloData :
            get the time delta of a halo data quantity as a function of age
        &#34;&#34;&#34;
        if quantity.startswith(&#34;delta&#34;):
            quantity = quantity[5:]

        #get redshifts and values for non-delta quantity
        zs, values = self.funcOfZHaloData(haloID, quantity)

        #calculate delta values
        deltaValues = values[1:]-values[:-1]
        #take off highest redshift from zs (can&#39;t calculate delta quantity
        # without an older snapshot)
        zs = zs[1:]

        return zs, deltaValues

    def funcOfAgeDeltaHaloData(self, haloID, quantity):
        &#34;&#34;&#34;
        Returns the change (delta) in a piece of halo data as a function of
        age in Gyr. To be used for quantities stored in the .AHF_halos file.

        Delta q at age t2 is calculated as q(t2)-q(t1) where t1 is the
        age of the previous snapshot. Note that this requires snapshots
        to have relatively even redshift spacing for delta quantities to be
        comparible over time.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;

        Returns
        -------
        ts : list of float
            The ages in Gyr correspond to each of the values in deltaValues
        deltaValues : list of float
            The delta values of the quantity specified

        See Also
        --------
        Cluster.funcOfZHaloData : get halo data as a function of redshift
        Cluster.funcOfAgeHaloData : get halo data as a function of age
        Cluster.funcOfZDeltaHaloData :
            get the time delta of a halo data quantity as a function of redshift
        &#34;&#34;&#34;
        zs, deltaValues = self.funcOfZDeltaHaloData(haloID,quantity)
        return analysis.tfromz(zs), deltaValues

    def funcOfZProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns a radius-dependent quantity as a function of redshift,
        interpolated at the given radius. To be used for quantities stored
        in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the profile data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfAgeProfileData
        Cluster.funcOfZDeltaProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
            return self.funcOfZDeltaProfileData(haloID,quantity[5:],radius)
        halos = self.trackHalo(haloID)
        zs = np.array([halo.z for halo in halos])
        values = []
        for halo in halos:
            rs, rvals = self.funcOfRadiusProfileData(halo.ID,quantity)
            interp = np.interp(radius, rs, rvals)
            values.append(interp)
        values = np.array(values)
        return zs, values

    def funcOfAgeProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns a radius-dependent quantity as a function of age,
        interpolated at the given radius. To be used for quantities stored
        in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the profile data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in values
        values : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfZDeltaProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        zs, values = self.funcOfZProfileData(haloID,quantity,radius)
        return analysis.tfromz(zs),values

    def funcOfZDeltaProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns the time delta of a radius-dependent quantity as a function of
        redshift, interpolated at the given radius.

        To be used for quantities stored in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        zs : list of float
            Array of redshifts that correspond to each of the values in
            deltaValues
        deltaValues : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfAgeProfileData
        Cluster.funcOfAgeDeltaProfileData
        &#34;&#34;&#34;
        if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
            quantity = quantity[5:]

        #get redshifts and values for non-delta quantity
        zs, values = self.funcOfZProfileData(haloID, quantity, radius)

        #calculate delta values
        deltaValues = values[1:]-values[:-1]
        #take off highest redshift from zs (can&#39;t calculate delta quantity
        # without an older snapshot)
        zs = zs[1:]
        return zs, deltaValues

    def funcOfAgeDeltaProfileData(self, haloID, quantity, radius):
        &#34;&#34;&#34;
        Returns the time delta of a radius-dependent quantity as a function of
        age, interpolated at the given radius.

        To be used for quantities stored in the .AHF_profiles files.

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate at z=0.
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Note that the quantity should not include a &#34;delta&#34;
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        radius : float
            The radius at which to interpolate the quantity specified

        Returns
        -------
        ages : list of float
            Array of ages in Gyr that correspond to each of the values in
            deltaValues
        deltaValues : list
            Array of values specified by quantity parameter as a function
            of time at specified radius

        See Also
        --------
        Cluster.funcOfZProfileData
        Cluster.funcOfAgeProfileData
        Cluster.funcOfZDeltaProfileData
        &#34;&#34;&#34;
        zs, deltaValues = self.funcOfZDeltaProfileData(haloID, quantity, radius)
        ages = analysis.tfromz(zs)
        return ages, deltaValues

    def funcOfRandZProfileDataPoints(self, masterHaloID, quantity, removeZeroes = False):
        &#34;&#34;&#34;
        Returns three 1d arrays that correspond to the coordinates of points
        with x = radius, y = redshift, z = quantity

        Uses radii that appear in AHF_profiles for each snapshot. Output comes
        as triangular grid (see notes).

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the halo being investigated in the *oldest*
            snapshot of interest
        quantity : str
            The name or column index of the profile data piece to use
        removeZeroes : bool
            Whether or not to remove points where the z value is 0. Default = False

        Returns
        -------
        r : array of float
            Array of radii in kpc/h
        z : array of float
            Array of redshifts
        val : array of float
            Array of values

        Notes
        -----
        The values returned from this function form a triangular grid, ideal for
        plotting with using matplotlib.pyplot.triplot or
        matplotlib.pyplot.plot_trisurf
        The values in z and r will not form a 2D grid, as the radii for each
        bin changes from snapshot to snapshot.

        See Also
        --------
        matplotlib.pyplot.triplot :
            Draw a unstructured triangular grid as lines and/or markers.
        mpl_toolkits.mplot3d.axes3d.Axes3D.plot_trisurf :
            Plot a triangulated surface
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        rs = np.empty(0)
        zs = np.empty(0)
        vals = np.empty(0)
        for haloID in haloIDs:

            #add rows to grid
            rrow, valrow = self.funcOfRadiusProfileData(haloID, quantity)
            zrow = [self.getHalo(haloID).z]*len(rrow)
            rs = np.concatenate((rs,rrow))
            zs = np.concatenate((zs,zrow))
            vals = np.concatenate((vals,valrow))

        if removeZeroes:
            #search for 0s in vals
            indexes = np.argwhere(vals==0)
            vals = np.delete(vals, indexes)
            rs = np.delete(rs, indexes)
            zs = np.delete(zs, indexes)
        return rs,zs,vals


    def funcOfRadiusProfileData(self, haloID, quantity, removeZeroes = False):
        &#34;&#34;&#34;
        Returns the profile quantity as a function of radius at the redshift
        corresponding to the snapshot number specified in haloID

        Parameters
        ----------
        haloID : int
            The full haloID of the halo to investigate
            e.g. 128000000000001
        quantity : str
            The name of the halo data piece to return
            e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
            Can alternatively be an integer that represents the index of a
            profile data piece (eg for Ly in column (10), can give quantity = 9)
            Note this is zero indexed.
        removeZeroes : bool, default = False
            If True will remove any entries where the value of {quantity} is 0

        Returns
        -------
        rs : array of float
            Array of radii that correspond to values in values
        values : array
            Array of values specified by quantity parameter as a function
            of radius
        &#34;&#34;&#34;
        halo = self.getHalo(haloID)
        rs = halo.radii()

        if type(quantity) == type(int()):
            #have passed an index rather than a string key
            values = halo.profiles[:,quantity]
        else:
            quantitydict = halo.getProfileQuantityDict()
            values = None
            try:
                values = quantitydict[quantity]()
            except KeyError as err:
                message = &#34;Invalid profile data quantity key {0}. To retrieve valid &#34;\
                          &#34;profile data keys, one can call &#34;\
                          &#34;Halo.getProfileQuantityDict() on a Halo instance, or use&#34;\
                          &#34; the quantity&#39;s column index (eg for Ly in column (10), &#34;\
                          &#34;can give quantity = 9)&#34;.format(quantity)
                raise KeyError(message) from err
        if removeZeroes:
            #search for 0s in vals
            indexes = np.argwhere(values==0)
            values = np.delete(values, indexes)
            rs = np.delete(rs, indexes)
        rs = np.array(rs)
        values = np.array(values)
        return rs, values

    def getMergeSize(self, haloID, scheme = &#34;halodata&#34;, fractional = True):
        &#34;&#34;&#34;
        Calculates the size of the merger that the halo experienced between
        snapshots.

        Parameters
        ----------
        haloID : int
            The halo ID of the halo being investigated, in the snapshot after
            the merge.
            (i.e. to get the size of the merger between snapshot 102 to 103, one
            would use the ID 10300000000000x)
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the returned size should be the fractional size
            (returned as a decimal), or the absolute size (returned as the
            number of particles).

        Returns
        -------
        size : number
            The size of the merger. If fractional is true, size will be a
            decimal float representing the fractional merger size, and if
            false, will be an integer number of particles.
            If the scheme is an mtree scheme, and the halo has no merger tree
            entry, will return -1.

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        validSchemes = [&#34;mtree-largest&#34;,&#34;mtree-sum&#34;,&#34;mtree-first&#34;,&#34;halodata&#34;]
        if scheme not in validSchemes:
            msg = &#34;Scheme &#39;{0}&#39; is not a valid scheme! Accepted values are: \n{1}&#34;.format(scheme,&#34;, &#34;.join(validSchemes))
            raise ValueError(msg)

        if scheme == &#34;mtree-largest&#34; or scheme == &#34;mtree-sum&#34; or scheme == &#34;mtree-first&#34;:
            #get merge tree entry
            mtreeEntry = self.getMergeTreeEntry(haloID)

            #if there is no merge tree entry for halo, return -1
            if type(mtreeEntry) == type(None):
                msg = &#34;Halo {0} has no merge tree entry! Returning -1&#34;.format(haloID)
                warnings.warn(msg, RuntimeWarning)
                return -1

            #get list of IDs of sub halos of father halo
            fatherID = self.getFatherOf(haloID)
            #assert(mtreeEntry[0,1]==fatherID)
            subHaloIDs = [halo.ID for halo in self.getEnclosedHalos(fatherID) if halo.hostHalo == fatherID]
            #go through merge tree entries and ignore any that are from
            # halos that were subhalos of the father halo
            #print(&#34;looking at halo {0}:&#34;.format(haloID))
            mergeSize = 0
            for mtreeRow in mtreeEntry[1:]:
                #(we exclude first row as that will be the father halo)
                progID = mtreeRow[1]
                if progID not in subHaloIDs:
                    #print(&#34;   non sub halo progenitor found: {0}&#34;.format(progID))
                    #print(&#34;   shared size is {0}&#34;.format(mtreeRow[0]))
                    #we have a progenitor that was not previously a subhalo
                    # therefore the particles introduced are new

                    #if using mtree-first we can stop here, if mtree-sum
                    # we keep going and add all of the non subhalo
                    # contributions, if mtree-largest we set mergeSize to
                    # the largest sharedPart we find
                    if scheme == &#34;mtree-first&#34;:
                        mergeSize = mtreeRow[0]
                        break
                    elif scheme == &#34;mtree-largest&#34;:
                        mergeSize = max(mergeSize,mtreeRow[0])
                    elif scheme == &#34;mtree-sum&#34;:
                        mergeSize += mtreeRow[0]

            #print(&#34;mergeSize is now {0}\n&#34;.format(mergeSize))

            if fractional:
                fatherSize = mtreeEntry[0,2]
                mergeSize /= fatherSize

            return mergeSize
        elif scheme == &#34;halodata&#34;:
            #scheme only relies on delta M and M from .AHF_halos file
            fatherID = self.getFatherOf(haloID)
            if fatherID == -1:
                return -1

            #calculate delta M
            fatherM = self.getHaloData(fatherID,&#34;Mvir&#34;)
            childM = self.getHaloData(haloID,&#34;Mvir&#34;)
            mergeSize = (childM-fatherM)

            #if fractional divide by father mass
            if fractional:
                mergeSize /= fatherM
            return mergeSize


    def getMergeZs(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
        &#34;&#34;&#34;
        Returns the red shifts at which halo experiences merger above specified
        threshold

        Parameters
        ----------
        haloIDtoTrack : int
            The full haloID of haloID to track - will track backwards through
            time
        threshold : float, default = 0.2
            The threshold for merge size
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        zs : array of floats
            The redshifts that correspond to the snapshots just after the merges
            occur
        sizes : array of floats
            The sizes of the mergers

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        zs = []
        sizes = []
        for haloID in self.trackID(haloIDtoTrack)[1:]:
            #get merge size
            mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)
            #check if merger is larger than threshold, if it is add redshift and
            # size to list to return
            if mergeSize &gt; threshold:
                zs.append(self.getHalo(haloID).z)
                sizes.append(mergeSize)
        return np.array(zs), np.array(sizes)

    def getMergeTimes(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
        &#34;&#34;&#34;
        Returns the ages at which halo experiences merger above specified
        threshold

        Parameters
        ----------
        haloIDtoTrack : int
            The full haloID of haloID to track - will track backwards through
            time
        threshold : float, default = 0.2
            The threshold for merge size
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        ages : array of floats
            The ages that correspond to the snapshots just after the merges
            occur
        sizes : array of floats
            The sizes of the mergers

        See Also
        --------
        TODO
        &#34;&#34;&#34;
        zs, sizes = self.getMergeZs(haloIDtoTrack,threshold=threshold,scheme=scheme,fractional=fractional)
        return analysis.tfromz(zs), sizes

    def getLargestMergeZInRange(self, masterHaloID, minZ, maxZ, scheme=&#34;halodata&#34;, fractional = True):
        &#34;&#34;&#34;
        Returns the redshift of the largest merger in the range of redshifts specified

        Parameters
        ----------
        masterHaloID : int
            Full haloID of halo to track in time in most recent snapshot
        minZ : float
            Defines minimum redshift for search range (inc.)
        maxZ : float
            Defines maximum redshift for search range (inc.)
        scheme : str, default = &#34;halodata&#34;
            Defines which scheme to use for calculating size of mergers.
            Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
            &#34;halodata&#34;
            To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
            a .BDP_enchalos file for the master halo.
            For an explanation of the schemes please see:
            https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
        fractional : bool, default = True
            Specifies whether the merger size should be the fractional size
            as a decimal, or the absolute size as the number of particles
            (mtree) / mass increment (halodata).

        Returns
        -------
        z : float
            The redshift at which the largest merger occurred in the range
            If the two largest mergers are of the same size will return redshift
            of earliest one.
            If there are no snapshots found with redshift inside range specified
            will be None
        largestMergeSize : int
            The size of the largest merge event found in range.
            If there are no snapshots found with redshift inside range specified
            will be 0
        &#34;&#34;&#34;
        if maxZ &lt; minZ:
            msg = &#34;Expected maxZ &gt;= minZ but got maxZ &lt; minZ!&#34;
            raise ValueError(msg)

        z = None
        largestMerge = 0
        #loop over chain of father halos, not including oldest snapshot
        # as we will not have data for its father&#39;s enclosed halos
        for haloID in self.trackID(masterHaloID)[1:]:
            #check if halo redshift is inside range specified, if not skip
            haloZ = self.getHalo(haloID).z
            if haloZ &lt; minZ or haloZ &gt; maxZ: continue

            #get merger size
            mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)

            if mergeSize &gt; largestMerge:
                z = haloZ
                largestMerge = mergeSize
        return z, largestMerge

    &#34;&#34;&#34;=============================&#34;&#34;&#34;
    &#34;&#34;&#34;   ENCLOSED HALO FUNCTIONS   &#34;&#34;&#34;
    &#34;&#34;&#34;=============================&#34;&#34;&#34;

    def generateEnclosedHaloFile(self,hostHaloID,haloFile,outputFile,useAHFSubHalos=False):
        &#34;&#34;&#34;
        Performs a search across all halos in haloFile as
        to whether they are contained within a sphere 2 times the virial radius
        of the host halo.
        Generates a file containing only the relevant information about only
        the halos that are enclosed within the host halo.

        Parameters
        ----------
        hostHaloID : int
        haloFile : string
        outputFile : string
        useAHFSubHalos : bool, default = False
            Specifies whether to use AHF sub halo detection instead of detection
            by position

        Notes
        -----
        (Unless useAHFSubHalos is True,)
        Does not use AHF&#39;s sub halo detection, due to how AHF defines subhalos
        (it is possible for an object to lie within a host halo and not be
        considered a sub halo if it is not within a common isodensity contour)

        See also
        --------
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        &#34;&#34;&#34;
        if useAHFSubHalos:
            raise NotImplementedError
        else:
            hostHalo = self.getHalo(hostHaloID)
            halorows = np.genfromtxt(haloFile)

            header = [&#34;ID(1)&#34;,&#34;hostHalo(2)&#34;,&#34;Xc(3)&#34;,&#34;Yc(4)&#34;,&#34;Zc(5)&#34;,&#34;VXc(6)&#34;,&#34;VYc(7)&#34;,&#34;VZc(8)&#34;]
            #the relevant indexes of the above quantities in the AHF_halos file
            quantityIndexes = [0,1,5,6,7,8,9,10]
            outputRows = np.empty((0,len(header)))
            for halorow in halorows:
                haloID = halorow[0]
                #check that the halo being considered isn&#39;t the host halo
                if haloID == hostHaloID: continue

                #check if the position of the halo satisfied criteria for being
                # enclosed
                x = halorow[5]
                y = halorow[6]
                z = halorow[7]

                #calculate distance to centre of hostHalo
                dist = np.sqrt((hostHalo.Xc-x)**2+(hostHalo.Yc-y)**2+(hostHalo.Zc-z)**2)
                if dist &lt; 2*hostHalo.Rvir:
                    #halo is enclosed by hostHalo
                    #we can add the relevant data to the output rows
                    outputRow = np.array([halorow[i] for i in quantityIndexes])
                    outputRows = np.vstack((outputRows,outputRow))

            #write output file
            np.savetxt(outputFile,outputRows,header=&#34;, &#34;.join(header))

    def generateEnclosedHaloFilesFromChain(self,masterHaloID,haloFiles,outputFileFmt,useAHFSubHalos=False):
        &#34;&#34;&#34;
        Generates an enclosed halo file for each halo in the chain of father halos
        of the master halo specifies.

        WARNING: May take a while to run

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the halo to track in the most recent snapshot
        haloFiles : list ( str )
            List of halo files to use, ordered in *ascending* snapshot order
        outputFileFmt : str
            Format of output file. Should contain a {haloID}, which will be
            replaced by the halo ID of the host halo the file refers to.
            e.g. &#34;GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;
        useAHFSubHalos : bool
            Specifies whether to use AHF sub halo detection instead of detection
            by position
        See also
        --------
        Cluster.generateEnclosedHaloFile()
        Cluster.loadEnclosedHaloFilesFromChain()
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        assert(len(haloIDs)==len(haloFiles))

        for i in range(len(haloIDs)):
            haloID = haloIDs[i]
            haloFile = haloFiles[i]
            outputFile = outputFileFmt.format(haloID=haloID)
            self.generateEnclosedHaloFile(haloID,haloFile,outputFile,useAHFSubHalos=useAHFSubHalos)


    def loadEnclosedHaloFile(self,hostHaloID,fileName):
        &#34;&#34;&#34;
        Loads data from an enclosed halo file (.BDP_enchalos) into the Cluster
        instance.

        Parameters
        ----------
        hostHaloID : int
            The full haloID of the host halo
        fileName : str

        Notes
        -----
        Will load subhalos in as HaloLite objects in an array accessable using
        Cluster.getEnclosedHalos(hostHaloID)

        See also
        --------
        Cluster.generateEnclosedHaloFile()
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.getEnclosedHalos()
        &#34;&#34;&#34;
        encHaloRows = np.genfromtxt(fileName)
        encHaloArray = []
        for encHaloRow in encHaloRows:
            halo = HaloLite(encHaloRow)
            encHaloArray.append(halo)

        self._encHaloDict[hostHaloID] = encHaloArray

    def loadEnclosedHaloFilesFromChain(self,masterHaloID,fileNameFmt):
        &#34;&#34;&#34;
        Loads data from enclosed halo files (.BDP_enchalos) into the Cluster
        instance, for each halo in the chain of father halos of the master halo

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the master halo in the most recent snapshot
        fileNameFmt : str
            The file name format of .BDP_enchalos file, with {haloID} as a
            placeholder for the haloID in the file name
            e.g. &#34;GX//GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;

        Notes
        -----
        Will load subhalos in as HaloLite objects in an array accessable using
        Cluster.getEnclosedHalos(hostHaloID)

        See also
        --------
        Cluster.getEnclosedHalos(hostHaloID)
        Cluster.loadEnclosedHaloFile()
        Cluster.generateEnclosedHaloFilesFromChain()
        Cluster.generateEnclosedHaloFile()
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        for haloID in haloIDs:
            self.loadEnclosedHaloFile(haloID,fileNameFmt.format(haloID=haloID))

    def getEnclosedHalos(self,hostHaloID):
        &#34;&#34;&#34;
        Gives the halos enclosed by the host halo specified

        Parameters
        ----------
        hostHaloID : int

        Returns
        -------
        enclosedHalos : list ( HaloLite )

        Notes
        -----
        Enclosed halo data must be loaded in for the halo in advance using
        Cluster.loadEnclosedHaloFile

        See also
        --------
        Cluster.loadEnclosedHaloFile
        &#34;&#34;&#34;
        try:
            return self._encHaloDict[hostHaloID]
        except KeyError as err:
            msg = &#34;ERROR: Halo {0} does not have enclosed halos loaded into memory!\n&#34;\
                  &#34;Before using data on enclosed halos, data must be loaded using&#34;\
                  &#34;Cluster.loadEnclosedHaloFile() or Cluster.loadEnclosedHaloFilesFromChain()&#34;.format(hostHaloID)
            raise Exception(msg) from err

    def getRelVelocitiesOfEncHalos(self, hostHaloID):
        &#34;&#34;&#34;
        Takes the halo ID of the host halo and returns an array of velocities of
        enclosed halos relative to host halo in km/s

        Parameters
        ----------
        hostHaloID : int

        Returns
        -------
        velocities : array ( array( Vx, Vy, Vz ) )

        See also
        --------
        Cluster.getRelSpeedsOfEncHalos()
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        &#34;&#34;&#34;
        encHalos = self.getEnclosedHalos(hostHaloID)
        velocities = []
        hostHalo = self.getHalo(hostHaloID)
        for encHalo in encHalos:
            relV = encHalo.vel - hostHalo.vel
            velocities.append(relV)
        return np.array(velocities)

    def getRelSpeedsOfEncHalos(self, hostHaloID, normalizeBy=None):
        &#34;&#34;&#34;
        Takes the halo ID of the host halo and returns an array of speeds of
        enclosed halos relative to host halo in km/s

        Parameters
        ----------
        hostHaloID : int
        normalizeBy : str, optional
            Specifies a halo data quantity of the host halo to normalize
            speeds by

        Returns
        -------
        speeds : array ( float )

        See also
        --------
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        Cluster.getRelVelocitiesOfEncHalos()
        &#34;&#34;&#34;
        velocities = self.getRelVelocitiesOfEncHalos(hostHaloID)
        speeds = np.array([np.linalg.norm(v) for v in velocities])
        #normalise speeds if specified
        if normalizeBy:
            haloVal = self.getHaloData(hostHaloID,normalizeBy)
            speeds = speeds / haloVal
        return speeds

    def genpColorMeshRelSpeedEncHalos(self, masterHaloID, nbins=40,
                                      normalizeBy=None, minv=None, maxv=None,
                                      useDensity = False):
        &#34;&#34;&#34;
        Generates data for the velocity distribution of enclosed halos as a
        function of time, in a format suitable for plotting on a matplotlib
        pcolormesh.

        Parameters
        ----------
        masterHaloID : int
            The full haloID of the host halo in the most recent snapshot
        nbins : int
            The number of bins (defines resolution in velocity axis)
        normalizeBy : str, optional
            Specifies a halo data quantity of the host halo to normalize
            speeds by
        minv : float, optional
            Specifies minimum speed of bins (ie position of lhs of plot)
        maxv : float, optional
            Specifies maximum speed of bins (ie position of rhs of plot)
        useDensity : bool, default = False
            Specifies whether to give each histogram&#39;s frequency as a decimal
            density rather than number frequency. Useful for preventing the
            flattening of color maps at higher redshift when many more objects
            are present in later snapshots

        Returns
        -------
        vv : numpy 2darray ( float )
            A 2D array of velocity bin edges that make up the x values of the
            meshgrid of the pcolormesh
        zz : numpy 2darray ( float )
            A 2D array of redshift bin edges that make up the y values of the
            meshgrid for the pcolormesh
        freq : numpy 2darray ( float )
            A 2D array of the frequencies of velocities within the bins.
            If vv and zz are N x M, freq will be N-1 x M-1 to fit with pcolormesh
            input format.

        Notes
        -----
        zz will be formatted such that the redshift of row i in freq corresponds
        to row i+1 of zz. This means that when plotting a pcolormesh, the z value
        a &#34;pixel&#34; corresponds to is the *edge* of the &#34;pixel&#34; on the side of
        *lowest* redshift.
        In other words, the highest redshift row of zz (the first row) does not
        correspond to the redshift of any loaded snapshots and exists only
        to specify the bounds of the highest redshift &#34;pixels&#34;

        See also
        --------
        Cluster.loadEnclosedHaloFilesFromChain()
        Cluster.loadEnclosedHaloFile()
        Cluster.getRelVelocitiesOfEncHalos()
        Cluster.getRelSpeedsOfEncHalos()
        matplotlib.axes.Axes.pcolormesh
        &#34;&#34;&#34;
        haloIDs = self.trackID(masterHaloID)
        #generate 2D array of speeds, where each row corresponds to each halo
        # in halo father chain
        speeds = []
        #will track minimum and maximum speeds as we go, to allow for the
        # histograms to have consistent ranges
        minspeed = +np.inf
        maxspeed = -np.inf
        for haloID in haloIDs:
            speedRow = self.getRelSpeedsOfEncHalos(haloID,normalizeBy=normalizeBy)
            speeds.append(speedRow)

            #update min and max
            minspeed = min(minspeed,speedRow.min())
            maxspeed = max(maxspeed,speedRow.max())

        #overwrite min and max speed with user input, if minv or maxv specified
        if minv: minspeed = minv
        if maxv: maxspeed = maxv

        #populate vv and freq with bin edges and frequencies respectively
        freq = []
        bin_edges = []

        for encSpeeds in speeds:
            #encSpeeds represents list of speeds of enclosed halos of specific
            # halo in chain
            hist, bin_edges = np.histogram(encSpeeds,bins=nbins,range=(minspeed,maxspeed),
                                           density=useDensity)
            freq.append(hist)
        #bin_edges should all be the same, as each histogram has same min, max,
        # and number of bins
        vv = [bin_edges]*(len(freq)+1)
        vv = np.array(vv)
        freq = np.array(freq)

        #populate zz
        zz = [[self.getHalo(haloID).z]*(nbins+1) for haloID in haloIDs]
        #zz is missing extra first row that specifies upper redshift bound of
        # highest redshift pixels, so we add an extra first row with higher
        # redshift
        upperZ = 2*zz[0][0]-zz[1][0]
        zz = [[upperZ]*(nbins+1)] + zz
        zz = np.array(zz)

        return vv, zz, freq</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData"><code class="name flex">
<span>def <span class="ident">funcOfAgeDeltaHaloData</span></span>(<span>self, haloID, quantity)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the change (delta) in a piece of halo data as a function of
age in Gyr. To be used for quantities stored in the .AHF_halos file.</p>
<p>Delta q at age t2 is calculated as q(t2)-q(t1) where t1 is the
age of the previous snapshot. Note that this requires snapshots
to have relatively even redshift spacing for delta quantities to be
comparible over time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "Rvir", "Mvir", "Ekin", "Qvir", etc
Note that the quantity should not include a "delta"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The ages in Gyr correspond to each of the values in deltaValues</dd>
<dt><strong><code>deltaValues</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The delta values of the quantity specified</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZHaloData" href="#ahfhalotools.objects.Cluster.funcOfZHaloData">Cluster.funcOfZHaloData()</a></code></dt>
<dd>get halo data as a function of redshift</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeHaloData">Cluster.funcOfAgeHaloData()</a></code></dt>
<dd>get halo data as a function of age</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaHaloData">Cluster.funcOfZDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of redshift</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfAgeDeltaHaloData(self, haloID, quantity):
    &#34;&#34;&#34;
    Returns the change (delta) in a piece of halo data as a function of
    age in Gyr. To be used for quantities stored in the .AHF_halos file.

    Delta q at age t2 is calculated as q(t2)-q(t1) where t1 is the
    age of the previous snapshot. Note that this requires snapshots
    to have relatively even redshift spacing for delta quantities to be
    comparible over time.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
        Note that the quantity should not include a &#34;delta&#34;

    Returns
    -------
    ts : list of float
        The ages in Gyr correspond to each of the values in deltaValues
    deltaValues : list of float
        The delta values of the quantity specified

    See Also
    --------
    Cluster.funcOfZHaloData : get halo data as a function of redshift
    Cluster.funcOfAgeHaloData : get halo data as a function of age
    Cluster.funcOfZDeltaHaloData :
        get the time delta of a halo data quantity as a function of redshift
    &#34;&#34;&#34;
    zs, deltaValues = self.funcOfZDeltaHaloData(haloID,quantity)
    return analysis.tfromz(zs), deltaValues</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData"><code class="name flex">
<span>def <span class="ident">funcOfAgeDeltaProfileData</span></span>(<span>self, haloID, quantity, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time delta of a radius-dependent quantity as a function of
age, interpolated at the given radius.</p>
<p>To be used for quantities stored in the .AHF_profiles files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "M_in_r", "encDens", "gasM_in_r", etc
Note that the quantity should not include a "delta"
Can alternatively be an integer that represents the index of a
profile data piece (eg for Ly in column (10), can give quantity = 9)
Note this is zero indexed.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius at which to interpolate the quantity specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ages</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of ages in Gyr that correspond to each of the values in
deltaValues</dd>
<dt><strong><code>deltaValues</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time at specified radius</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.funcOfZProfileData" href="#ahfhalotools.objects.Cluster.funcOfZProfileData">Cluster.funcOfZProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfAgeProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeProfileData">Cluster.funcOfAgeProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaProfileData">Cluster.funcOfZDeltaProfileData()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfAgeDeltaProfileData(self, haloID, quantity, radius):
    &#34;&#34;&#34;
    Returns the time delta of a radius-dependent quantity as a function of
    age, interpolated at the given radius.

    To be used for quantities stored in the .AHF_profiles files.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
        Note that the quantity should not include a &#34;delta&#34;
        Can alternatively be an integer that represents the index of a
        profile data piece (eg for Ly in column (10), can give quantity = 9)
        Note this is zero indexed.
    radius : float
        The radius at which to interpolate the quantity specified

    Returns
    -------
    ages : list of float
        Array of ages in Gyr that correspond to each of the values in
        deltaValues
    deltaValues : list
        Array of values specified by quantity parameter as a function
        of time at specified radius

    See Also
    --------
    Cluster.funcOfZProfileData
    Cluster.funcOfAgeProfileData
    Cluster.funcOfZDeltaProfileData
    &#34;&#34;&#34;
    zs, deltaValues = self.funcOfZDeltaProfileData(haloID, quantity, radius)
    ages = analysis.tfromz(zs)
    return ages, deltaValues</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfAgeHaloData"><code class="name flex">
<span>def <span class="ident">funcOfAgeHaloData</span></span>(<span>self, haloID, quantity)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a piece of halo data as a function of age. To be used for
quantities stored in the .AHF_halos file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "Rvir", "Mvir", "Ekin", "Qvir", etc
Returns time delta of quantities when key is preceded by "delta",
e.g. "deltaRvir", "deltaMvir", "deltaEkin", etc</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ages</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of ages in Gyr that correspond to each of the values in values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZHaloData" href="#ahfhalotools.objects.Cluster.funcOfZHaloData">Cluster.funcOfZHaloData()</a></code></dt>
<dd>get halo data as a function of redshift</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaHaloData">Cluster.funcOfZDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of redshift</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData">Cluster.funcOfAgeDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of age</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfAgeHaloData(self, haloID, quantity):
    &#34;&#34;&#34;
    Returns a piece of halo data as a function of age. To be used for
    quantities stored in the .AHF_halos file.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
        Returns time delta of quantities when key is preceded by &#34;delta&#34;,
        e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

    Returns
    -------
    ages : list of float
        Array of ages in Gyr that correspond to each of the values in values
    values : list
        Array of values specified by quantity parameter as a function
        of time

    See Also
    --------
    Cluster.funcOfZHaloData : get halo data as a function of redshift
    Cluster.funcOfZDeltaHaloData :
        get the time delta of a halo data quantity as a function of redshift
    Cluster.funcOfAgeDeltaHaloData :
        get the time delta of a halo data quantity as a function of age
    &#34;&#34;&#34;
    zs, values = self.funcOfZHaloData(haloID,quantity)
    return analysis.tfromz(zs), values</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfAgeProfileData"><code class="name flex">
<span>def <span class="ident">funcOfAgeProfileData</span></span>(<span>self, haloID, quantity, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a radius-dependent quantity as a function of age,
interpolated at the given radius. To be used for quantities stored
in the .AHF_profiles files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the profile data piece to return
e.g. "M_in_r", "encDens", "gasM_in_r", etc
Can alternatively be an integer that represents the index of a
profile data piece (eg for Ly in column (10), can give quantity = 9)
Note this is zero indexed.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius at which to interpolate the quantity specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ages</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of ages in Gyr that correspond to each of the values in values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time at specified radius</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.funcOfZProfileData" href="#ahfhalotools.objects.Cluster.funcOfZProfileData">Cluster.funcOfZProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaProfileData">Cluster.funcOfZDeltaProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData">Cluster.funcOfAgeDeltaProfileData()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfAgeProfileData(self, haloID, quantity, radius):
    &#34;&#34;&#34;
    Returns a radius-dependent quantity as a function of age,
    interpolated at the given radius. To be used for quantities stored
    in the .AHF_profiles files.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the profile data piece to return
        e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
        Can alternatively be an integer that represents the index of a
        profile data piece (eg for Ly in column (10), can give quantity = 9)
        Note this is zero indexed.
    radius : float
        The radius at which to interpolate the quantity specified

    Returns
    -------
    ages : list of float
        Array of ages in Gyr that correspond to each of the values in values
    values : list
        Array of values specified by quantity parameter as a function
        of time at specified radius

    See Also
    --------
    Cluster.funcOfZProfileData
    Cluster.funcOfZDeltaProfileData
    Cluster.funcOfAgeDeltaProfileData
    &#34;&#34;&#34;
    zs, values = self.funcOfZProfileData(haloID,quantity,radius)
    return analysis.tfromz(zs),values</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfRadiusProfileData"><code class="name flex">
<span>def <span class="ident">funcOfRadiusProfileData</span></span>(<span>self, haloID, quantity, removeZeroes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the profile quantity as a function of radius at the redshift
corresponding to the snapshot number specified in haloID</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "M_in_r", "encDens", "gasM_in_r", etc
Can alternatively be an integer that represents the index of a
profile data piece (eg for Ly in column (10), can give quantity = 9)
Note this is zero indexed.</dd>
<dt><strong><code>removeZeroes</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>If True will remove any entries where the value of {quantity} is 0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rs</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>Array of radii that correspond to values in values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of values specified by quantity parameter as a function
of radius</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfRadiusProfileData(self, haloID, quantity, removeZeroes = False):
    &#34;&#34;&#34;
    Returns the profile quantity as a function of radius at the redshift
    corresponding to the snapshot number specified in haloID

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
        Can alternatively be an integer that represents the index of a
        profile data piece (eg for Ly in column (10), can give quantity = 9)
        Note this is zero indexed.
    removeZeroes : bool, default = False
        If True will remove any entries where the value of {quantity} is 0

    Returns
    -------
    rs : array of float
        Array of radii that correspond to values in values
    values : array
        Array of values specified by quantity parameter as a function
        of radius
    &#34;&#34;&#34;
    halo = self.getHalo(haloID)
    rs = halo.radii()

    if type(quantity) == type(int()):
        #have passed an index rather than a string key
        values = halo.profiles[:,quantity]
    else:
        quantitydict = halo.getProfileQuantityDict()
        values = None
        try:
            values = quantitydict[quantity]()
        except KeyError as err:
            message = &#34;Invalid profile data quantity key {0}. To retrieve valid &#34;\
                      &#34;profile data keys, one can call &#34;\
                      &#34;Halo.getProfileQuantityDict() on a Halo instance, or use&#34;\
                      &#34; the quantity&#39;s column index (eg for Ly in column (10), &#34;\
                      &#34;can give quantity = 9)&#34;.format(quantity)
            raise KeyError(message) from err
    if removeZeroes:
        #search for 0s in vals
        indexes = np.argwhere(values==0)
        values = np.delete(values, indexes)
        rs = np.delete(rs, indexes)
    rs = np.array(rs)
    values = np.array(values)
    return rs, values</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfRandZProfileDataPoints"><code class="name flex">
<span>def <span class="ident">funcOfRandZProfileDataPoints</span></span>(<span>self, masterHaloID, quantity, removeZeroes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns three 1d arrays that correspond to the coordinates of points
with x = radius, y = redshift, z = quantity</p>
<p>Uses radii that appear in AHF_profiles for each snapshot. Output comes
as triangular grid (see notes).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo being investigated in the <em>oldest</em>
snapshot of interest</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name or column index of the profile data piece to use</dd>
<dt><strong><code>removeZeroes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to remove points where the z value is 0. Default = False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>Array of radii in kpc/h</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>Array of redshifts</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>Array of values</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The values returned from this function form a triangular grid, ideal for
plotting with using matplotlib.pyplot.triplot or
matplotlib.pyplot.plot_trisurf
The values in z and r will not form a 2D grid, as the radii for each
bin changes from snapshot to snapshot.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>matplotlib.pyplot.triplot</code></dt>
<dd>Draw a unstructured triangular grid as lines and/or markers.</dd>
<dt><code>mpl_toolkits.mplot3d.axes3d.Axes3D.plot_trisurf</code></dt>
<dd>Plot a triangulated surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfRandZProfileDataPoints(self, masterHaloID, quantity, removeZeroes = False):
    &#34;&#34;&#34;
    Returns three 1d arrays that correspond to the coordinates of points
    with x = radius, y = redshift, z = quantity

    Uses radii that appear in AHF_profiles for each snapshot. Output comes
    as triangular grid (see notes).

    Parameters
    ----------
    masterHaloID : int
        The full haloID of the halo being investigated in the *oldest*
        snapshot of interest
    quantity : str
        The name or column index of the profile data piece to use
    removeZeroes : bool
        Whether or not to remove points where the z value is 0. Default = False

    Returns
    -------
    r : array of float
        Array of radii in kpc/h
    z : array of float
        Array of redshifts
    val : array of float
        Array of values

    Notes
    -----
    The values returned from this function form a triangular grid, ideal for
    plotting with using matplotlib.pyplot.triplot or
    matplotlib.pyplot.plot_trisurf
    The values in z and r will not form a 2D grid, as the radii for each
    bin changes from snapshot to snapshot.

    See Also
    --------
    matplotlib.pyplot.triplot :
        Draw a unstructured triangular grid as lines and/or markers.
    mpl_toolkits.mplot3d.axes3d.Axes3D.plot_trisurf :
        Plot a triangulated surface
    &#34;&#34;&#34;
    haloIDs = self.trackID(masterHaloID)
    rs = np.empty(0)
    zs = np.empty(0)
    vals = np.empty(0)
    for haloID in haloIDs:

        #add rows to grid
        rrow, valrow = self.funcOfRadiusProfileData(haloID, quantity)
        zrow = [self.getHalo(haloID).z]*len(rrow)
        rs = np.concatenate((rs,rrow))
        zs = np.concatenate((zs,zrow))
        vals = np.concatenate((vals,valrow))

    if removeZeroes:
        #search for 0s in vals
        indexes = np.argwhere(vals==0)
        vals = np.delete(vals, indexes)
        rs = np.delete(rs, indexes)
        zs = np.delete(zs, indexes)
    return rs,zs,vals</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfZDeltaHaloData"><code class="name flex">
<span>def <span class="ident">funcOfZDeltaHaloData</span></span>(<span>self, haloID, quantity)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the change (delta) in a piece of halo data as a function of
redshift. To be used for quantities stored in the .AHF_halos file.</p>
<p>Delta q at redshift z2 is calculated as q(z2)-q(z1) where z1 is the
redshift of the previous snapshot. Note that this requires snapshots
to have relatively even redshift spacing for delta quantities to be
comparible over time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "Rvir", "Mvir", "Ekin", "Qvir", etc
Note that the quantity should not include a "delta"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The redshifts correspond to each of the values in deltaValues</dd>
<dt><strong><code>deltaValues</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The delta values of the quantity specified</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZHaloData" href="#ahfhalotools.objects.Cluster.funcOfZHaloData">Cluster.funcOfZHaloData()</a></code></dt>
<dd>get halo data as a function of redshift</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeHaloData">Cluster.funcOfAgeHaloData()</a></code></dt>
<dd>get halo data as a function of age</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData">Cluster.funcOfAgeDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of age</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfZDeltaHaloData(self, haloID, quantity):
    &#34;&#34;&#34;
    Returns the change (delta) in a piece of halo data as a function of
    redshift. To be used for quantities stored in the .AHF_halos file.

    Delta q at redshift z2 is calculated as q(z2)-q(z1) where z1 is the
    redshift of the previous snapshot. Note that this requires snapshots
    to have relatively even redshift spacing for delta quantities to be
    comparible over time.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
        Note that the quantity should not include a &#34;delta&#34;

    Returns
    -------
    zs : list of float
        The redshifts correspond to each of the values in deltaValues
    deltaValues : list of float
        The delta values of the quantity specified

    See Also
    --------
    Cluster.funcOfZHaloData : get halo data as a function of redshift
    Cluster.funcOfAgeHaloData : get halo data as a function of age
    Cluster.funcOfAgeDeltaHaloData :
        get the time delta of a halo data quantity as a function of age
    &#34;&#34;&#34;
    if quantity.startswith(&#34;delta&#34;):
        quantity = quantity[5:]

    #get redshifts and values for non-delta quantity
    zs, values = self.funcOfZHaloData(haloID, quantity)

    #calculate delta values
    deltaValues = values[1:]-values[:-1]
    #take off highest redshift from zs (can&#39;t calculate delta quantity
    # without an older snapshot)
    zs = zs[1:]

    return zs, deltaValues</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfZDeltaProfileData"><code class="name flex">
<span>def <span class="ident">funcOfZDeltaProfileData</span></span>(<span>self, haloID, quantity, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time delta of a radius-dependent quantity as a function of
redshift, interpolated at the given radius.</p>
<p>To be used for quantities stored in the .AHF_profiles files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "M_in_r", "encDens", "gasM_in_r", etc
Note that the quantity should not include a "delta"
Can alternatively be an integer that represents the index of a
profile data piece (eg for Ly in column (10), can give quantity = 9)
Note this is zero indexed.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius at which to interpolate the quantity specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of redshifts that correspond to each of the values in
deltaValues</dd>
<dt><strong><code>deltaValues</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time at specified radius</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.funcOfZProfileData" href="#ahfhalotools.objects.Cluster.funcOfZProfileData">Cluster.funcOfZProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfAgeProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeProfileData">Cluster.funcOfAgeProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData">Cluster.funcOfAgeDeltaProfileData()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfZDeltaProfileData(self, haloID, quantity, radius):
    &#34;&#34;&#34;
    Returns the time delta of a radius-dependent quantity as a function of
    redshift, interpolated at the given radius.

    To be used for quantities stored in the .AHF_profiles files.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
        Note that the quantity should not include a &#34;delta&#34;
        Can alternatively be an integer that represents the index of a
        profile data piece (eg for Ly in column (10), can give quantity = 9)
        Note this is zero indexed.
    radius : float
        The radius at which to interpolate the quantity specified

    Returns
    -------
    zs : list of float
        Array of redshifts that correspond to each of the values in
        deltaValues
    deltaValues : list
        Array of values specified by quantity parameter as a function
        of time at specified radius

    See Also
    --------
    Cluster.funcOfZProfileData
    Cluster.funcOfAgeProfileData
    Cluster.funcOfAgeDeltaProfileData
    &#34;&#34;&#34;
    if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
        quantity = quantity[5:]

    #get redshifts and values for non-delta quantity
    zs, values = self.funcOfZProfileData(haloID, quantity, radius)

    #calculate delta values
    deltaValues = values[1:]-values[:-1]
    #take off highest redshift from zs (can&#39;t calculate delta quantity
    # without an older snapshot)
    zs = zs[1:]
    return zs, deltaValues</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfZHaloData"><code class="name flex">
<span>def <span class="ident">funcOfZHaloData</span></span>(<span>self, haloID, quantity)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a piece of halo data as a function of redshift. To be used for
quantities stored in the .AHF_halos file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "Rvir", "Mvir", "Ekin", "Qvir", etc
Returns time delta of quantities when key is preceded by "delta",
e.g. "deltaRvir", "deltaMvir", "deltaEkin", etc</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of redshifts that correspond to each of the values in values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeHaloData">Cluster.funcOfAgeHaloData()</a></code></dt>
<dd>get halo data as a function of age</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaHaloData">Cluster.funcOfZDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of redshift</dd>
<dt><code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData">Cluster.funcOfAgeDeltaHaloData()</a></code></dt>
<dd>get the time delta of a halo data quantity as a function of age</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfZHaloData(self, haloID, quantity):
    &#34;&#34;&#34;
    Returns a piece of halo data as a function of redshift. To be used for
    quantities stored in the .AHF_halos file.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
        Returns time delta of quantities when key is preceded by &#34;delta&#34;,
        e.g. &#34;deltaRvir&#34;, &#34;deltaMvir&#34;, &#34;deltaEkin&#34;, etc

    Returns
    -------
    zs : list of float
        Array of redshifts that correspond to each of the values in values
    values : list
        Array of values specified by quantity parameter as a function
        of time

    See Also
    --------
    Cluster.funcOfAgeHaloData : get halo data as a function of age
    Cluster.funcOfZDeltaHaloData :
        get the time delta of a halo data quantity as a function of redshift
    Cluster.funcOfAgeDeltaHaloData :
        get the time delta of a halo data quantity as a function of age
    &#34;&#34;&#34;
    if quantity.startswith(&#34;delta&#34;):
        #return delta value instead of normal value
        return self.funcOfZDeltaHaloData(haloID,quantity[5:])

    #for normal values:
    halos = self.trackHalo(haloID)
    zs = np.array([halo.z for halo in halos])
    values = None
    try:
        values = np.array([halo.halodata[quantity] for halo in halos])
    except KeyError as err:
        msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
              &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
              &#34;instance.&#34;.format(quantity)
        raise KeyError(msg) from err
    return zs, values</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.funcOfZProfileData"><code class="name flex">
<span>def <span class="ident">funcOfZProfileData</span></span>(<span>self, haloID, quantity, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a radius-dependent quantity as a function of redshift,
interpolated at the given radius. To be used for quantities stored
in the .AHF_profiles files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the profile data piece to return
e.g. "M_in_r", "encDens", "gasM_in_r", etc
Can alternatively be an integer that represents the index of a
profile data piece (eg for Ly in column (10), can give quantity = 9)
Note this is zero indexed.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius at which to interpolate the quantity specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>Array of redshifts that correspond to each of the values in values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>Array of values specified by quantity parameter as a function
of time at specified radius</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.funcOfAgeProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeProfileData">Cluster.funcOfAgeProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaProfileData">Cluster.funcOfZDeltaProfileData()</a></code>
<code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData">Cluster.funcOfAgeDeltaProfileData()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcOfZProfileData(self, haloID, quantity, radius):
    &#34;&#34;&#34;
    Returns a radius-dependent quantity as a function of redshift,
    interpolated at the given radius. To be used for quantities stored
    in the .AHF_profiles files.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the profile data piece to return
        e.g. &#34;M_in_r&#34;, &#34;encDens&#34;, &#34;gasM_in_r&#34;, etc
        Can alternatively be an integer that represents the index of a
        profile data piece (eg for Ly in column (10), can give quantity = 9)
        Note this is zero indexed.
    radius : float
        The radius at which to interpolate the quantity specified

    Returns
    -------
    zs : list of float
        Array of redshifts that correspond to each of the values in values
    values : list
        Array of values specified by quantity parameter as a function
        of time at specified radius

    See Also
    --------
    Cluster.funcOfAgeProfileData
    Cluster.funcOfZDeltaProfileData
    Cluster.funcOfAgeDeltaProfileData
    &#34;&#34;&#34;
    if type(quantity) == type(str()) and quantity.startswith(&#34;delta&#34;):
        return self.funcOfZDeltaProfileData(haloID,quantity[5:],radius)
    halos = self.trackHalo(haloID)
    zs = np.array([halo.z for halo in halos])
    values = []
    for halo in halos:
        rs, rvals = self.funcOfRadiusProfileData(halo.ID,quantity)
        interp = np.interp(radius, rs, rvals)
        values.append(interp)
    values = np.array(values)
    return zs, values</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.generateEnclosedHaloFile"><code class="name flex">
<span>def <span class="ident">generateEnclosedHaloFile</span></span>(<span>self, hostHaloID, haloFile, outputFile, useAHFSubHalos=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a search across all halos in haloFile as
to whether they are contained within a sphere 2 times the virial radius
of the host halo.
Generates a file containing only the relevant information about only
the halos that are enclosed within the host halo.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>haloFile</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>outputFile</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>useAHFSubHalos</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>Specifies whether to use AHF sub halo detection instead of detection
by position</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>(Unless useAHFSubHalos is True,)
Does not use AHF's sub halo detection, due to how AHF defines subhalos
(it is possible for an object to lie within a host halo and not be
considered a sub halo if it is not within a common isodensity contour)</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain">Cluster.generateEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateEnclosedHaloFile(self,hostHaloID,haloFile,outputFile,useAHFSubHalos=False):
    &#34;&#34;&#34;
    Performs a search across all halos in haloFile as
    to whether they are contained within a sphere 2 times the virial radius
    of the host halo.
    Generates a file containing only the relevant information about only
    the halos that are enclosed within the host halo.

    Parameters
    ----------
    hostHaloID : int
    haloFile : string
    outputFile : string
    useAHFSubHalos : bool, default = False
        Specifies whether to use AHF sub halo detection instead of detection
        by position

    Notes
    -----
    (Unless useAHFSubHalos is True,)
    Does not use AHF&#39;s sub halo detection, due to how AHF defines subhalos
    (it is possible for an object to lie within a host halo and not be
    considered a sub halo if it is not within a common isodensity contour)

    See also
    --------
    Cluster.generateEnclosedHaloFilesFromChain()
    Cluster.loadEnclosedHaloFile()
    &#34;&#34;&#34;
    if useAHFSubHalos:
        raise NotImplementedError
    else:
        hostHalo = self.getHalo(hostHaloID)
        halorows = np.genfromtxt(haloFile)

        header = [&#34;ID(1)&#34;,&#34;hostHalo(2)&#34;,&#34;Xc(3)&#34;,&#34;Yc(4)&#34;,&#34;Zc(5)&#34;,&#34;VXc(6)&#34;,&#34;VYc(7)&#34;,&#34;VZc(8)&#34;]
        #the relevant indexes of the above quantities in the AHF_halos file
        quantityIndexes = [0,1,5,6,7,8,9,10]
        outputRows = np.empty((0,len(header)))
        for halorow in halorows:
            haloID = halorow[0]
            #check that the halo being considered isn&#39;t the host halo
            if haloID == hostHaloID: continue

            #check if the position of the halo satisfied criteria for being
            # enclosed
            x = halorow[5]
            y = halorow[6]
            z = halorow[7]

            #calculate distance to centre of hostHalo
            dist = np.sqrt((hostHalo.Xc-x)**2+(hostHalo.Yc-y)**2+(hostHalo.Zc-z)**2)
            if dist &lt; 2*hostHalo.Rvir:
                #halo is enclosed by hostHalo
                #we can add the relevant data to the output rows
                outputRow = np.array([halorow[i] for i in quantityIndexes])
                outputRows = np.vstack((outputRows,outputRow))

        #write output file
        np.savetxt(outputFile,outputRows,header=&#34;, &#34;.join(header))</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain"><code class="name flex">
<span>def <span class="ident">generateEnclosedHaloFilesFromChain</span></span>(<span>self, masterHaloID, haloFiles, outputFileFmt, useAHFSubHalos=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an enclosed halo file for each halo in the chain of father halos
of the master halo specifies.</p>
<p>WARNING: May take a while to run</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to track in the most recent snapshot</dd>
<dt><strong><code>haloFiles</code></strong> :&ensp;<code>list ( str )</code></dt>
<dd>List of halo files to use, ordered in <em>ascending</em> snapshot order</dd>
<dt><strong><code>outputFileFmt</code></strong> :&ensp;<code>str</code></dt>
<dd>Format of output file. Should contain a {haloID}, which will be
replaced by the halo ID of the host halo the file refers to.
e.g. "GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos"</dd>
<dt><strong><code>useAHFSubHalos</code></strong> :&ensp;<code>bool</code></dt>
<dd>Specifies whether to use AHF sub halo detection instead of detection
by position</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFile">Cluster.generateEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain">Cluster.loadEnclosedHaloFilesFromChain()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateEnclosedHaloFilesFromChain(self,masterHaloID,haloFiles,outputFileFmt,useAHFSubHalos=False):
    &#34;&#34;&#34;
    Generates an enclosed halo file for each halo in the chain of father halos
    of the master halo specifies.

    WARNING: May take a while to run

    Parameters
    ----------
    masterHaloID : int
        The full haloID of the halo to track in the most recent snapshot
    haloFiles : list ( str )
        List of halo files to use, ordered in *ascending* snapshot order
    outputFileFmt : str
        Format of output file. Should contain a {haloID}, which will be
        replaced by the halo ID of the host halo the file refers to.
        e.g. &#34;GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;
    useAHFSubHalos : bool
        Specifies whether to use AHF sub halo detection instead of detection
        by position
    See also
    --------
    Cluster.generateEnclosedHaloFile()
    Cluster.loadEnclosedHaloFilesFromChain()
    &#34;&#34;&#34;
    haloIDs = self.trackID(masterHaloID)
    assert(len(haloIDs)==len(haloFiles))

    for i in range(len(haloIDs)):
        haloID = haloIDs[i]
        haloFile = haloFiles[i]
        outputFile = outputFileFmt.format(haloID=haloID)
        self.generateEnclosedHaloFile(haloID,haloFile,outputFile,useAHFSubHalos=useAHFSubHalos)</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.genpColorMeshRelSpeedEncHalos"><code class="name flex">
<span>def <span class="ident">genpColorMeshRelSpeedEncHalos</span></span>(<span>self, masterHaloID, nbins=40, normalizeBy=None, minv=None, maxv=None, useDensity=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates data for the velocity distribution of enclosed halos as a
function of time, in a format suitable for plotting on a matplotlib
pcolormesh.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the host halo in the most recent snapshot</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of bins (defines resolution in velocity axis)</dd>
<dt><strong><code>normalizeBy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies a halo data quantity of the host halo to normalize
speeds by</dd>
<dt><strong><code>minv</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Specifies minimum speed of bins (ie position of lhs of plot)</dd>
<dt><strong><code>maxv</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Specifies maximum speed of bins (ie position of rhs of plot)</dd>
<dt><strong><code>useDensity</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>Specifies whether to give each histogram's frequency as a decimal
density rather than number frequency. Useful for preventing the
flattening of color maps at higher redshift when many more objects
are present in later snapshots</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>vv</code></strong> :&ensp;<code>numpy 2darray ( float )</code></dt>
<dd>A 2D array of velocity bin edges that make up the x values of the
meshgrid of the pcolormesh</dd>
<dt><strong><code>zz</code></strong> :&ensp;<code>numpy 2darray ( float )</code></dt>
<dd>A 2D array of redshift bin edges that make up the y values of the
meshgrid for the pcolormesh</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>numpy 2darray ( float )</code></dt>
<dd>A 2D array of the frequencies of velocities within the bins.
If vv and zz are N x M, freq will be N-1 x M-1 to fit with pcolormesh
input format.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>zz will be formatted such that the redshift of row i in freq corresponds
to row i+1 of zz. This means that when plotting a pcolormesh, the z value
a "pixel" corresponds to is the <em>edge</em> of the "pixel" on the side of
<em>lowest</em> redshift.
In other words, the highest redshift row of zz (the first row) does not
correspond to the redshift of any loaded snapshots and exists only
to specify the bounds of the highest redshift "pixels"</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain">Cluster.loadEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos">Cluster.getRelVelocitiesOfEncHalos()</a></code>
<code><a title="ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos">Cluster.getRelSpeedsOfEncHalos()</a></code>
<code>matplotlib.axes.Axes.pcolormesh</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genpColorMeshRelSpeedEncHalos(self, masterHaloID, nbins=40,
                                  normalizeBy=None, minv=None, maxv=None,
                                  useDensity = False):
    &#34;&#34;&#34;
    Generates data for the velocity distribution of enclosed halos as a
    function of time, in a format suitable for plotting on a matplotlib
    pcolormesh.

    Parameters
    ----------
    masterHaloID : int
        The full haloID of the host halo in the most recent snapshot
    nbins : int
        The number of bins (defines resolution in velocity axis)
    normalizeBy : str, optional
        Specifies a halo data quantity of the host halo to normalize
        speeds by
    minv : float, optional
        Specifies minimum speed of bins (ie position of lhs of plot)
    maxv : float, optional
        Specifies maximum speed of bins (ie position of rhs of plot)
    useDensity : bool, default = False
        Specifies whether to give each histogram&#39;s frequency as a decimal
        density rather than number frequency. Useful for preventing the
        flattening of color maps at higher redshift when many more objects
        are present in later snapshots

    Returns
    -------
    vv : numpy 2darray ( float )
        A 2D array of velocity bin edges that make up the x values of the
        meshgrid of the pcolormesh
    zz : numpy 2darray ( float )
        A 2D array of redshift bin edges that make up the y values of the
        meshgrid for the pcolormesh
    freq : numpy 2darray ( float )
        A 2D array of the frequencies of velocities within the bins.
        If vv and zz are N x M, freq will be N-1 x M-1 to fit with pcolormesh
        input format.

    Notes
    -----
    zz will be formatted such that the redshift of row i in freq corresponds
    to row i+1 of zz. This means that when plotting a pcolormesh, the z value
    a &#34;pixel&#34; corresponds to is the *edge* of the &#34;pixel&#34; on the side of
    *lowest* redshift.
    In other words, the highest redshift row of zz (the first row) does not
    correspond to the redshift of any loaded snapshots and exists only
    to specify the bounds of the highest redshift &#34;pixels&#34;

    See also
    --------
    Cluster.loadEnclosedHaloFilesFromChain()
    Cluster.loadEnclosedHaloFile()
    Cluster.getRelVelocitiesOfEncHalos()
    Cluster.getRelSpeedsOfEncHalos()
    matplotlib.axes.Axes.pcolormesh
    &#34;&#34;&#34;
    haloIDs = self.trackID(masterHaloID)
    #generate 2D array of speeds, where each row corresponds to each halo
    # in halo father chain
    speeds = []
    #will track minimum and maximum speeds as we go, to allow for the
    # histograms to have consistent ranges
    minspeed = +np.inf
    maxspeed = -np.inf
    for haloID in haloIDs:
        speedRow = self.getRelSpeedsOfEncHalos(haloID,normalizeBy=normalizeBy)
        speeds.append(speedRow)

        #update min and max
        minspeed = min(minspeed,speedRow.min())
        maxspeed = max(maxspeed,speedRow.max())

    #overwrite min and max speed with user input, if minv or maxv specified
    if minv: minspeed = minv
    if maxv: maxspeed = maxv

    #populate vv and freq with bin edges and frequencies respectively
    freq = []
    bin_edges = []

    for encSpeeds in speeds:
        #encSpeeds represents list of speeds of enclosed halos of specific
        # halo in chain
        hist, bin_edges = np.histogram(encSpeeds,bins=nbins,range=(minspeed,maxspeed),
                                       density=useDensity)
        freq.append(hist)
    #bin_edges should all be the same, as each histogram has same min, max,
    # and number of bins
    vv = [bin_edges]*(len(freq)+1)
    vv = np.array(vv)
    freq = np.array(freq)

    #populate zz
    zz = [[self.getHalo(haloID).z]*(nbins+1) for haloID in haloIDs]
    #zz is missing extra first row that specifies upper redshift bound of
    # highest redshift pixels, so we add an extra first row with higher
    # redshift
    upperZ = 2*zz[0][0]-zz[1][0]
    zz = [[upperZ]*(nbins+1)] + zz
    zz = np.array(zz)

    return vv, zz, freq</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getEnclosedHalos"><code class="name flex">
<span>def <span class="ident">getEnclosedHalos</span></span>(<span>self, hostHaloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the halos enclosed by the host halo specified</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>enclosedHalos</code></strong> :&ensp;<code>list ( <a title="ahfhalotools.objects.HaloLite" href="#ahfhalotools.objects.HaloLite">HaloLite</a> )</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Enclosed halo data must be loaded in for the halo in advance using
Cluster.loadEnclosedHaloFile</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEnclosedHalos(self,hostHaloID):
    &#34;&#34;&#34;
    Gives the halos enclosed by the host halo specified

    Parameters
    ----------
    hostHaloID : int

    Returns
    -------
    enclosedHalos : list ( HaloLite )

    Notes
    -----
    Enclosed halo data must be loaded in for the halo in advance using
    Cluster.loadEnclosedHaloFile

    See also
    --------
    Cluster.loadEnclosedHaloFile
    &#34;&#34;&#34;
    try:
        return self._encHaloDict[hostHaloID]
    except KeyError as err:
        msg = &#34;ERROR: Halo {0} does not have enclosed halos loaded into memory!\n&#34;\
              &#34;Before using data on enclosed halos, data must be loaded using&#34;\
              &#34;Cluster.loadEnclosedHaloFile() or Cluster.loadEnclosedHaloFilesFromChain()&#34;.format(hostHaloID)
        raise Exception(msg) from err</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getFatherOf"><code class="name flex">
<span>def <span class="ident">getFatherOf</span></span>(<span>self, haloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the haloID of the father halo</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo
e.g. 128000000000002, 102000000000023</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fatherID</code></strong> :&ensp;<code>int</code></dt>
<dd>The haloID of the father halo
If no such father exists (either due to truncation or end of file),
returns -1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFatherOf(self, haloID):
    &#34;&#34;&#34;
    Returns the haloID of the father halo

    Parameters
    ----------
    haloID : int
        The full haloID of the halo
        e.g. 128000000000002, 102000000000023

    Returns
    -------
    fatherID : int
        The haloID of the father halo
        If no such father exists (either due to truncation or end of file),
        returns -1
    &#34;&#34;&#34;
    try:
        return self._fatherDict[haloID]
    except KeyError:
        #no father stored for halo, so will return -1
        return -1</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getHalo"><code class="name flex">
<span>def <span class="ident">getHalo</span></span>(<span>self, haloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the Halo instance corresponding to the halo ID. If the ID is
invalid, will return -1</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo
e.g. 128000000000002, 102000000000023</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>halo</code></strong> :&ensp;<code><a title="ahfhalotools.objects.Halo" href="#ahfhalotools.objects.Halo">Halo</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHalo(self, haloID):
    &#34;&#34;&#34;
    Gets the Halo instance corresponding to the halo ID. If the ID is
    invalid, will return -1

    Parameters
    ----------
    haloID : int
        The full haloID of the halo
        e.g. 128000000000002, 102000000000023

    Returns
    -------
    halo : Halo object
    &#34;&#34;&#34;
    try:
        halo = self._haloDict[haloID]
    except KeyError:
        halo = -1
    return halo</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getHaloData"><code class="name flex">
<span>def <span class="ident">getHaloData</span></span>(<span>self, haloID, quantity)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to retrieve values of halo data from a specified halo</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo to investigate at z=0.
e.g. 128000000000001</dd>
<dt><strong><code>quantity</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the halo data piece to return
e.g. "Rvir", "Mvir", "Ekin", "Qvir", etc
Does not accept delta quantities</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>value</code></dt>
<dd>The halo data value corresponding to quantity specified</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHaloData(self, haloID, quantity):
    &#34;&#34;&#34;
    Used to retrieve values of halo data from a specified halo

    Parameters
    ----------
    haloID : int
        The full haloID of the halo to investigate at z=0.
        e.g. 128000000000001
    quantity : str
        The name of the halo data piece to return
        e.g. &#34;Rvir&#34;, &#34;Mvir&#34;, &#34;Ekin&#34;, &#34;Qvir&#34;, etc
        Does not accept delta quantities

    Returns
    -------
    value
        The halo data value corresponding to quantity specified
    &#34;&#34;&#34;
    halo = self.getHalo(haloID)
    try:
        return halo.halodata[quantity]
    except KeyError as err:
        msg = &#34;Invalid Halo Data quantity key {0}. To retreive valid &#34;\
              &#34;halodata keys, one can call Halo.halodata.keys() on a Halo &#34;\
              &#34;instance.&#34;.format(quantity)
        raise KeyError(msg) from err
    except AttributeError:
        #self.getHalo has returned -1, ie we do not have the halo specified
        #loaded into memory
        return -1</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getLargestMergeZInRange"><code class="name flex">
<span>def <span class="ident">getLargestMergeZInRange</span></span>(<span>self, masterHaloID, minZ, maxZ, scheme='halodata', fractional=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the redshift of the largest merger in the range of redshifts specified</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>Full haloID of halo to track in time in most recent snapshot</dd>
<dt><strong><code>minZ</code></strong> :&ensp;<code>float</code></dt>
<dd>Defines minimum redshift for search range (inc.)</dd>
<dt><strong><code>maxZ</code></strong> :&ensp;<code>float</code></dt>
<dd>Defines maximum redshift for search range (inc.)</dd>
<dt><strong><code>scheme</code></strong> :&ensp;<code>str</code>, default <code>= "halodata"</code></dt>
<dd>Defines which scheme to use for calculating size of mergers.
Valid values are "mtree-largest", "mtree-sum", "mtree-first", or
"halodata"
To use "mtree-largest" or "mtree-sum", one must have already loaded
a .BDP_enchalos file for the master halo.
For an explanation of the schemes please see:
<a href="https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md">https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md</a></dd>
<dt><strong><code>fractional</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Specifies whether the merger size should be the fractional size
as a decimal, or the absolute size as the number of particles
(mtree) / mass increment (halodata).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The redshift at which the largest merger occurred in the range
If the two largest mergers are of the same size will return redshift
of earliest one.
If there are no snapshots found with redshift inside range specified
will be None</dd>
<dt><strong><code>largestMergeSize</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the largest merge event found in range.
If there are no snapshots found with redshift inside range specified
will be 0</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLargestMergeZInRange(self, masterHaloID, minZ, maxZ, scheme=&#34;halodata&#34;, fractional = True):
    &#34;&#34;&#34;
    Returns the redshift of the largest merger in the range of redshifts specified

    Parameters
    ----------
    masterHaloID : int
        Full haloID of halo to track in time in most recent snapshot
    minZ : float
        Defines minimum redshift for search range (inc.)
    maxZ : float
        Defines maximum redshift for search range (inc.)
    scheme : str, default = &#34;halodata&#34;
        Defines which scheme to use for calculating size of mergers.
        Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
        &#34;halodata&#34;
        To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
        a .BDP_enchalos file for the master halo.
        For an explanation of the schemes please see:
        https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
    fractional : bool, default = True
        Specifies whether the merger size should be the fractional size
        as a decimal, or the absolute size as the number of particles
        (mtree) / mass increment (halodata).

    Returns
    -------
    z : float
        The redshift at which the largest merger occurred in the range
        If the two largest mergers are of the same size will return redshift
        of earliest one.
        If there are no snapshots found with redshift inside range specified
        will be None
    largestMergeSize : int
        The size of the largest merge event found in range.
        If there are no snapshots found with redshift inside range specified
        will be 0
    &#34;&#34;&#34;
    if maxZ &lt; minZ:
        msg = &#34;Expected maxZ &gt;= minZ but got maxZ &lt; minZ!&#34;
        raise ValueError(msg)

    z = None
    largestMerge = 0
    #loop over chain of father halos, not including oldest snapshot
    # as we will not have data for its father&#39;s enclosed halos
    for haloID in self.trackID(masterHaloID)[1:]:
        #check if halo redshift is inside range specified, if not skip
        haloZ = self.getHalo(haloID).z
        if haloZ &lt; minZ or haloZ &gt; maxZ: continue

        #get merger size
        mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)

        if mergeSize &gt; largestMerge:
            z = haloZ
            largestMerge = mergeSize
    return z, largestMerge</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getMergeSize"><code class="name flex">
<span>def <span class="ident">getMergeSize</span></span>(<span>self, haloID, scheme='halodata', fractional=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the size of the merger that the halo experienced between
snapshots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The halo ID of the halo being investigated, in the snapshot after
the merge.
(i.e. to get the size of the merger between snapshot 102 to 103, one
would use the ID 10300000000000x)</dd>
<dt><strong><code>scheme</code></strong> :&ensp;<code>str</code>, default <code>= "halodata"</code></dt>
<dd>Defines which scheme to use for calculating size of mergers.
Valid values are "mtree-largest", "mtree-sum", "mtree-first", or
"halodata"
To use "mtree-largest" or "mtree-sum", one must have already loaded
a .BDP_enchalos file for the master halo.
For an explanation of the schemes please see:
<a href="https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md">https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md</a></dd>
<dt><strong><code>fractional</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Specifies whether the returned size should be the fractional size
(returned as a decimal), or the absolute size (returned as the
number of particles).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>number</code></dt>
<dd>The size of the merger. If fractional is true, size will be a
decimal float representing the fractional merger size, and if
false, will be an integer number of particles.
If the scheme is an mtree scheme, and the halo has no merger tree
entry, will return -1.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>TODO</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMergeSize(self, haloID, scheme = &#34;halodata&#34;, fractional = True):
    &#34;&#34;&#34;
    Calculates the size of the merger that the halo experienced between
    snapshots.

    Parameters
    ----------
    haloID : int
        The halo ID of the halo being investigated, in the snapshot after
        the merge.
        (i.e. to get the size of the merger between snapshot 102 to 103, one
        would use the ID 10300000000000x)
    scheme : str, default = &#34;halodata&#34;
        Defines which scheme to use for calculating size of mergers.
        Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
        &#34;halodata&#34;
        To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
        a .BDP_enchalos file for the master halo.
        For an explanation of the schemes please see:
        https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
    fractional : bool, default = True
        Specifies whether the returned size should be the fractional size
        (returned as a decimal), or the absolute size (returned as the
        number of particles).

    Returns
    -------
    size : number
        The size of the merger. If fractional is true, size will be a
        decimal float representing the fractional merger size, and if
        false, will be an integer number of particles.
        If the scheme is an mtree scheme, and the halo has no merger tree
        entry, will return -1.

    See Also
    --------
    TODO
    &#34;&#34;&#34;
    validSchemes = [&#34;mtree-largest&#34;,&#34;mtree-sum&#34;,&#34;mtree-first&#34;,&#34;halodata&#34;]
    if scheme not in validSchemes:
        msg = &#34;Scheme &#39;{0}&#39; is not a valid scheme! Accepted values are: \n{1}&#34;.format(scheme,&#34;, &#34;.join(validSchemes))
        raise ValueError(msg)

    if scheme == &#34;mtree-largest&#34; or scheme == &#34;mtree-sum&#34; or scheme == &#34;mtree-first&#34;:
        #get merge tree entry
        mtreeEntry = self.getMergeTreeEntry(haloID)

        #if there is no merge tree entry for halo, return -1
        if type(mtreeEntry) == type(None):
            msg = &#34;Halo {0} has no merge tree entry! Returning -1&#34;.format(haloID)
            warnings.warn(msg, RuntimeWarning)
            return -1

        #get list of IDs of sub halos of father halo
        fatherID = self.getFatherOf(haloID)
        #assert(mtreeEntry[0,1]==fatherID)
        subHaloIDs = [halo.ID for halo in self.getEnclosedHalos(fatherID) if halo.hostHalo == fatherID]
        #go through merge tree entries and ignore any that are from
        # halos that were subhalos of the father halo
        #print(&#34;looking at halo {0}:&#34;.format(haloID))
        mergeSize = 0
        for mtreeRow in mtreeEntry[1:]:
            #(we exclude first row as that will be the father halo)
            progID = mtreeRow[1]
            if progID not in subHaloIDs:
                #print(&#34;   non sub halo progenitor found: {0}&#34;.format(progID))
                #print(&#34;   shared size is {0}&#34;.format(mtreeRow[0]))
                #we have a progenitor that was not previously a subhalo
                # therefore the particles introduced are new

                #if using mtree-first we can stop here, if mtree-sum
                # we keep going and add all of the non subhalo
                # contributions, if mtree-largest we set mergeSize to
                # the largest sharedPart we find
                if scheme == &#34;mtree-first&#34;:
                    mergeSize = mtreeRow[0]
                    break
                elif scheme == &#34;mtree-largest&#34;:
                    mergeSize = max(mergeSize,mtreeRow[0])
                elif scheme == &#34;mtree-sum&#34;:
                    mergeSize += mtreeRow[0]

        #print(&#34;mergeSize is now {0}\n&#34;.format(mergeSize))

        if fractional:
            fatherSize = mtreeEntry[0,2]
            mergeSize /= fatherSize

        return mergeSize
    elif scheme == &#34;halodata&#34;:
        #scheme only relies on delta M and M from .AHF_halos file
        fatherID = self.getFatherOf(haloID)
        if fatherID == -1:
            return -1

        #calculate delta M
        fatherM = self.getHaloData(fatherID,&#34;Mvir&#34;)
        childM = self.getHaloData(haloID,&#34;Mvir&#34;)
        mergeSize = (childM-fatherM)

        #if fractional divide by father mass
        if fractional:
            mergeSize /= fatherM
        return mergeSize</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getMergeTimes"><code class="name flex">
<span>def <span class="ident">getMergeTimes</span></span>(<span>self, haloIDtoTrack, threshold=0.2, scheme='halodata', fractional=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ages at which halo experiences merger above specified
threshold</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloIDtoTrack</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of haloID to track - will track backwards through
time</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, default <code>= 0.2</code></dt>
<dd>The threshold for merge size</dd>
<dt><strong><code>scheme</code></strong> :&ensp;<code>str</code>, default <code>= "halodata"</code></dt>
<dd>Defines which scheme to use for calculating size of mergers.
Valid values are "mtree-largest", "mtree-sum", "mtree-first", or
"halodata"
To use "mtree-largest" or "mtree-sum", one must have already loaded
a .BDP_enchalos file for the master halo.
For an explanation of the schemes please see:
<a href="https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md">https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md</a></dd>
<dt><strong><code>fractional</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Specifies whether the merger size should be the fractional size
as a decimal, or the absolute size as the number of particles
(mtree) / mass increment (halodata).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ages</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The ages that correspond to the snapshots just after the merges
occur</dd>
<dt><strong><code>sizes</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The sizes of the mergers</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>TODO</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMergeTimes(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
    &#34;&#34;&#34;
    Returns the ages at which halo experiences merger above specified
    threshold

    Parameters
    ----------
    haloIDtoTrack : int
        The full haloID of haloID to track - will track backwards through
        time
    threshold : float, default = 0.2
        The threshold for merge size
    scheme : str, default = &#34;halodata&#34;
        Defines which scheme to use for calculating size of mergers.
        Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
        &#34;halodata&#34;
        To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
        a .BDP_enchalos file for the master halo.
        For an explanation of the schemes please see:
        https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
    fractional : bool, default = True
        Specifies whether the merger size should be the fractional size
        as a decimal, or the absolute size as the number of particles
        (mtree) / mass increment (halodata).

    Returns
    -------
    ages : array of floats
        The ages that correspond to the snapshots just after the merges
        occur
    sizes : array of floats
        The sizes of the mergers

    See Also
    --------
    TODO
    &#34;&#34;&#34;
    zs, sizes = self.getMergeZs(haloIDtoTrack,threshold=threshold,scheme=scheme,fractional=fractional)
    return analysis.tfromz(zs), sizes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getMergeTreeEntry"><code class="name flex">
<span>def <span class="ident">getMergeTreeEntry</span></span>(<span>self, haloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns merger tree entry for halo.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the halo</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mtree_entry</code></strong> :&ensp;<code>array</code> of <code>3-tuples</code></dt>
<dd>Formatted as [[sharedPart, progenitorID, progenitorPart]]
(Same format as .AHF_mtree entry)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMergeTreeEntry(self, haloID):
    &#34;&#34;&#34;
    Returns merger tree entry for halo.

    Parameters
    ----------
    haloID : int
        The full haloID of the halo

    Returns
    -------
    mtree_entry : array of 3-tuples
        Formatted as [[sharedPart, progenitorID, progenitorPart]]
        (Same format as .AHF_mtree entry)
    &#34;&#34;&#34;
    try:
        return self._progDict[haloID]
    except KeyError:
        #haloID is probably in earliest snapshot loaded
        return None</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getMergeZs"><code class="name flex">
<span>def <span class="ident">getMergeZs</span></span>(<span>self, haloIDtoTrack, threshold=0.2, scheme='halodata', fractional=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the red shifts at which halo experiences merger above specified
threshold</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>haloIDtoTrack</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of haloID to track - will track backwards through
time</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, default <code>= 0.2</code></dt>
<dd>The threshold for merge size</dd>
<dt><strong><code>scheme</code></strong> :&ensp;<code>str</code>, default <code>= "halodata"</code></dt>
<dd>Defines which scheme to use for calculating size of mergers.
Valid values are "mtree-largest", "mtree-sum", "mtree-first", or
"halodata"
To use "mtree-largest" or "mtree-sum", one must have already loaded
a .BDP_enchalos file for the master halo.
For an explanation of the schemes please see:
<a href="https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md">https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md</a></dd>
<dt><strong><code>fractional</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Specifies whether the merger size should be the fractional size
as a decimal, or the absolute size as the number of particles
(mtree) / mass increment (halodata).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zs</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The redshifts that correspond to the snapshots just after the merges
occur</dd>
<dt><strong><code>sizes</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The sizes of the mergers</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>TODO</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMergeZs(self,haloIDtoTrack,threshold=0.2,scheme=&#34;halodata&#34;,fractional=True):
    &#34;&#34;&#34;
    Returns the red shifts at which halo experiences merger above specified
    threshold

    Parameters
    ----------
    haloIDtoTrack : int
        The full haloID of haloID to track - will track backwards through
        time
    threshold : float, default = 0.2
        The threshold for merge size
    scheme : str, default = &#34;halodata&#34;
        Defines which scheme to use for calculating size of mergers.
        Valid values are &#34;mtree-largest&#34;, &#34;mtree-sum&#34;, &#34;mtree-first&#34;, or
        &#34;halodata&#34;
        To use &#34;mtree-largest&#34; or &#34;mtree-sum&#34;, one must have already loaded
        a .BDP_enchalos file for the master halo.
        For an explanation of the schemes please see:
        https://github.com/BenDavisonPetch/ahfhalotools/blob/main/merger_detection_scheme_guide.md
    fractional : bool, default = True
        Specifies whether the merger size should be the fractional size
        as a decimal, or the absolute size as the number of particles
        (mtree) / mass increment (halodata).

    Returns
    -------
    zs : array of floats
        The redshifts that correspond to the snapshots just after the merges
        occur
    sizes : array of floats
        The sizes of the mergers

    See Also
    --------
    TODO
    &#34;&#34;&#34;
    zs = []
    sizes = []
    for haloID in self.trackID(haloIDtoTrack)[1:]:
        #get merge size
        mergeSize = self.getMergeSize(haloID,scheme=scheme,fractional=fractional)
        #check if merger is larger than threshold, if it is add redshift and
        # size to list to return
        if mergeSize &gt; threshold:
            zs.append(self.getHalo(haloID).z)
            sizes.append(mergeSize)
    return np.array(zs), np.array(sizes)</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos"><code class="name flex">
<span>def <span class="ident">getRelSpeedsOfEncHalos</span></span>(<span>self, hostHaloID, normalizeBy=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the halo ID of the host halo and returns an array of speeds of
enclosed halos relative to host halo in km/s</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>normalizeBy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies a halo data quantity of the host halo to normalize
speeds by</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>speeds</code></strong> :&ensp;<code>array ( float )</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain">Cluster.loadEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos">Cluster.getRelVelocitiesOfEncHalos()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRelSpeedsOfEncHalos(self, hostHaloID, normalizeBy=None):
    &#34;&#34;&#34;
    Takes the halo ID of the host halo and returns an array of speeds of
    enclosed halos relative to host halo in km/s

    Parameters
    ----------
    hostHaloID : int
    normalizeBy : str, optional
        Specifies a halo data quantity of the host halo to normalize
        speeds by

    Returns
    -------
    speeds : array ( float )

    See also
    --------
    Cluster.loadEnclosedHaloFilesFromChain()
    Cluster.loadEnclosedHaloFile()
    Cluster.getRelVelocitiesOfEncHalos()
    &#34;&#34;&#34;
    velocities = self.getRelVelocitiesOfEncHalos(hostHaloID)
    speeds = np.array([np.linalg.norm(v) for v in velocities])
    #normalise speeds if specified
    if normalizeBy:
        haloVal = self.getHaloData(hostHaloID,normalizeBy)
        speeds = speeds / haloVal
    return speeds</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos"><code class="name flex">
<span>def <span class="ident">getRelVelocitiesOfEncHalos</span></span>(<span>self, hostHaloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the halo ID of the host halo and returns an array of velocities of
enclosed halos relative to host halo in km/s</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>velocities</code></strong> :&ensp;<code>array ( array( Vx, Vy, Vz ) )</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos">Cluster.getRelSpeedsOfEncHalos()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain">Cluster.loadEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRelVelocitiesOfEncHalos(self, hostHaloID):
    &#34;&#34;&#34;
    Takes the halo ID of the host halo and returns an array of velocities of
    enclosed halos relative to host halo in km/s

    Parameters
    ----------
    hostHaloID : int

    Returns
    -------
    velocities : array ( array( Vx, Vy, Vz ) )

    See also
    --------
    Cluster.getRelSpeedsOfEncHalos()
    Cluster.loadEnclosedHaloFilesFromChain()
    Cluster.loadEnclosedHaloFile()
    &#34;&#34;&#34;
    encHalos = self.getEnclosedHalos(hostHaloID)
    velocities = []
    hostHalo = self.getHalo(hostHaloID)
    for encHalo in encHalos:
        relV = encHalo.vel - hostHalo.vel
        velocities.append(relV)
    return np.array(velocities)</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.loadEnclosedHaloFile"><code class="name flex">
<span>def <span class="ident">loadEnclosedHaloFile</span></span>(<span>self, hostHaloID, fileName)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data from an enclosed halo file (.BDP_enchalos) into the Cluster
instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the host halo</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Will load subhalos in as HaloLite objects in an array accessable using
Cluster.getEnclosedHalos(hostHaloID)</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFile">Cluster.generateEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain">Cluster.generateEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.getEnclosedHalos" href="#ahfhalotools.objects.Cluster.getEnclosedHalos">Cluster.getEnclosedHalos()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadEnclosedHaloFile(self,hostHaloID,fileName):
    &#34;&#34;&#34;
    Loads data from an enclosed halo file (.BDP_enchalos) into the Cluster
    instance.

    Parameters
    ----------
    hostHaloID : int
        The full haloID of the host halo
    fileName : str

    Notes
    -----
    Will load subhalos in as HaloLite objects in an array accessable using
    Cluster.getEnclosedHalos(hostHaloID)

    See also
    --------
    Cluster.generateEnclosedHaloFile()
    Cluster.generateEnclosedHaloFilesFromChain()
    Cluster.getEnclosedHalos()
    &#34;&#34;&#34;
    encHaloRows = np.genfromtxt(fileName)
    encHaloArray = []
    for encHaloRow in encHaloRows:
        halo = HaloLite(encHaloRow)
        encHaloArray.append(halo)

    self._encHaloDict[hostHaloID] = encHaloArray</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain"><code class="name flex">
<span>def <span class="ident">loadEnclosedHaloFilesFromChain</span></span>(<span>self, masterHaloID, fileNameFmt)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data from enclosed halo files (.BDP_enchalos) into the Cluster
instance, for each halo in the chain of father halos of the master halo</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterHaloID</code></strong> :&ensp;<code>int</code></dt>
<dd>The full haloID of the master halo in the most recent snapshot</dd>
<dt><strong><code>fileNameFmt</code></strong> :&ensp;<code>str</code></dt>
<dd>The file name format of .BDP_enchalos file, with {haloID} as a
placeholder for the haloID in the file name
e.g. "GX//GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos"</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Will load subhalos in as HaloLite objects in an array accessable using
Cluster.getEnclosedHalos(hostHaloID)</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.getEnclosedHalos" href="#ahfhalotools.objects.Cluster.getEnclosedHalos">Cluster.getEnclosedHalos()</a>(hostHaloID)</code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain">Cluster.generateEnclosedHaloFilesFromChain()</a></code>
<code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFile">Cluster.generateEnclosedHaloFile()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadEnclosedHaloFilesFromChain(self,masterHaloID,fileNameFmt):
    &#34;&#34;&#34;
    Loads data from enclosed halo files (.BDP_enchalos) into the Cluster
    instance, for each halo in the chain of father halos of the master halo

    Parameters
    ----------
    masterHaloID : int
        The full haloID of the master halo in the most recent snapshot
    fileNameFmt : str
        The file name format of .BDP_enchalos file, with {haloID} as a
        placeholder for the haloID in the file name
        e.g. &#34;GX//GadgetX-NewMDCLUSTER_0001.halo{haloID}.BDP_enchalos&#34;

    Notes
    -----
    Will load subhalos in as HaloLite objects in an array accessable using
    Cluster.getEnclosedHalos(hostHaloID)

    See also
    --------
    Cluster.getEnclosedHalos(hostHaloID)
    Cluster.loadEnclosedHaloFile()
    Cluster.generateEnclosedHaloFilesFromChain()
    Cluster.generateEnclosedHaloFile()
    &#34;&#34;&#34;
    haloIDs = self.trackID(masterHaloID)
    for haloID in haloIDs:
        self.loadEnclosedHaloFile(haloID,fileNameFmt.format(haloID=haloID))</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.trackHalo"><code class="name flex">
<span>def <span class="ident">trackHalo</span></span>(<span>self, haloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a haloID and returns an array of halos corresponding to
the chain of father halos backwards in time. If there are gaps in
stored halos, those halos will be skipped</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.trackID" href="#ahfhalotools.objects.Cluster.trackID">Cluster.trackID()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trackHalo(self,haloID):
    &#34;&#34;&#34;
    Takes a haloID and returns an array of halos corresponding to
    the chain of father halos backwards in time. If there are gaps in
    stored halos, those halos will be skipped

    See Also
    --------
    Cluster.trackID()
    &#34;&#34;&#34;
    chainIDs = self.trackID(haloID)
    halos = []
    for id in chainIDs:
        halo = self.getHalo(id)
        if halo != -1: halos.append(halo)
    return halos</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Cluster.trackID"><code class="name flex">
<span>def <span class="ident">trackID</span></span>(<span>self, haloID)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a haloID and returns an array of haloIDs corresponding to
the chain of father halos backwards in time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trackID(self, haloID):
    &#34;&#34;&#34;
    Takes a haloID and returns an array of haloIDs corresponding to
    the chain of father halos backwards in time
    &#34;&#34;&#34;
    fatherID = self.getFatherOf(haloID)
    if fatherID == -1:
        #end of chain, return just current haloID
        return [haloID]
    else:
        return self.trackID(fatherID) + [haloID]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ahfhalotools.objects.Halo"><code class="flex name class">
<span>class <span class="ident">Halo</span></span>
<span>(</span><span>halodata, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores information about a single halo at a single point in time.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>halodata</code></strong> :&ensp;<code>dict (str : ?)</code></dt>
<dd>Dictionary of halo data quantities</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of halo</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Redshift of halo</dd>
<dt><strong><code>age</code></strong> :&ensp;<code>float</code></dt>
<dd>Age of halo in Gyr</dd>
<dt><strong><code>sigV</code></strong> :&ensp;<code>float</code></dt>
<dd>3D velocity dispersion of halo in km/s</dd>
<dt><strong><code>Rvir</code></strong> :&ensp;<code>float</code></dt>
<dd>Virial radius in kpc/h</dd>
<dt><strong><code>Xc</code></strong> :&ensp;<code>float</code></dt>
<dd>x position of halo in kpc/h (comoving)</dd>
<dt><strong><code>Yc</code></strong> :&ensp;<code>float</code></dt>
<dd>y position of halo in kpc/h (comoving)</dd>
<dt><strong><code>Zc</code></strong> :&ensp;<code>float</code></dt>
<dd>z position of halo in kpc/h (comoving)</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>np.array ( float )</code></dt>
<dd>3D position vector of halo in kpc/h (comoving)
Equal to [Xc,Yc,Zc]</dd>
<dt><strong><code>vel</code></strong> :&ensp;<code>np.array ( float )</code></dt>
<dd>3D velocity vector of halo in km/s</dd>
<dt><strong><code>mbp_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset between most bound particle and halo centre in kpc/h</dd>
<dt><strong><code>com_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Offset between centre-of-mass and halo centre in kpc/h</dd>
<dt><strong><code>Ekin</code></strong> :&ensp;<code>float</code></dt>
<dd>Kinetic energy in Msol/h (km/s)^2</dd>
<dt><strong><code>Epot</code></strong> :&ensp;<code>float</code></dt>
<dd>Potential energy in Msol/h (km/s)^2</dd>
<dt><strong><code>Qvir</code></strong> :&ensp;<code>float</code></dt>
<dd>Virial ratio
Equal to -Ekin/Epot</dd>
<dt><strong><code>profiles</code></strong> :&ensp;<code>2D array</code> of <code>float</code></dt>
<dd>Raw profile data</dd>
<dt><strong><code>rawhalodata</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>Raw halodata row</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>To fully initialise halo, one must manually add each profile row using
Halo.addProfile()</p>
<p>All named halo data attributes are also present in the halodata dictionary.</p>
<p>To retreive valid halodata keys, one can call Halo.halodata.keys() on a
Halo instance.</p>
<p>To retrieve valid profile data keys, one can call Halo.getProfileQuantityDict()
on a Halo instance.</p>
<p>Raw profile data can be accessed using Halo.profiles, which contains a
list of rows corresponding to rows in the .AHF_profiles file. This can be
used to retrive profile data that does not have a defined function in the
Halo class (e.g. to get vcirc, which is column 6 in .AHF_profiles, one can
call Halo.profiles[:,5])</p>
<p>Initialises halo instance from row of halodata</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>halodata</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>The row of halo data from the .AHF_halos file</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The redshift of the snapshot the halo belongs to</dd>
</dl>
<h2 id="notes_1">Notes</h2>
<p>To fully initialise halo, one must manually add each row of profile data
using Halo.addProfile()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Halo:
    &#34;&#34;&#34;
    Stores information about a single halo at a single point in time.

    Attributes
    ----------
    halodata : dict (str : ?)
        Dictionary of halo data quantities
    ID : int
        ID of halo
    z : float
        Redshift of halo
    age : float
        Age of halo in Gyr
    sigV : float
        3D velocity dispersion of halo in km/s
    Rvir : float
        Virial radius in kpc/h
    Xc : float
        x position of halo in kpc/h (comoving)
    Yc : float
        y position of halo in kpc/h (comoving)
    Zc : float
        z position of halo in kpc/h (comoving)
    pos : np.array ( float )
        3D position vector of halo in kpc/h (comoving)
        Equal to [Xc,Yc,Zc]
    vel : np.array ( float )
        3D velocity vector of halo in km/s
    mbp_offset : float
        Offset between most bound particle and halo centre in kpc/h
    com_offset : float
        Offset between centre-of-mass and halo centre in kpc/h
    Ekin : float
        Kinetic energy in Msol/h (km/s)^2
    Epot : float
        Potential energy in Msol/h (km/s)^2
    Qvir : float
        Virial ratio
        Equal to -Ekin/Epot
    profiles : 2D array of float
        Raw profile data
    rawhalodata : array of dtype float
        Raw halodata row

    Notes
    -----
    To fully initialise halo, one must manually add each profile row using
    Halo.addProfile()

    All named halo data attributes are also present in the halodata dictionary.

    To retreive valid halodata keys, one can call Halo.halodata.keys() on a
    Halo instance.

    To retrieve valid profile data keys, one can call Halo.getProfileQuantityDict()
    on a Halo instance.

    Raw profile data can be accessed using Halo.profiles, which contains a
    list of rows corresponding to rows in the .AHF_profiles file. This can be
    used to retrive profile data that does not have a defined function in the
    Halo class (e.g. to get vcirc, which is column 6 in .AHF_profiles, one can
    call Halo.profiles[:,5])
    &#34;&#34;&#34;
    def __init__(self, halodata, z):
        &#34;&#34;&#34;
        Initialises halo instance from row of halodata

        Parameters
        ----------
        halodata : array of float
            The row of halo data from the .AHF_halos file
        z : float
            The redshift of the snapshot the halo belongs to

        Notes
        -----
        To fully initialise halo, one must manually add each row of profile data
        using Halo.addProfile()
        &#34;&#34;&#34;
        halodata_columns = [&#39;ID&#39;, &#39;hostHalo&#39;, &#39;numSubStruct&#39;, &#39;Mvir&#39;, &#39;npart&#39;,
            &#39;Xc&#39;, &#39;Yc&#39;, &#39;Zc&#39;, &#39;VXc&#39;, &#39;VYc&#39;, &#39;VZc&#39;, &#39;Rvir&#39;, &#39;Rmax&#39;, &#39;r2&#39;,
            &#39;mbp_offset&#39;, &#39;com_offset&#39;, &#39;Vmax&#39;, &#39;v_esc&#39;, &#39;sigV&#39;, &#39;lambda&#39;,
            &#39;lambdaE&#39;, &#39;Lx&#39;, &#39;Ly&#39;, &#39;Lz&#39;, &#39;b&#39;, &#39;c&#39;, &#39;Eax&#39;, &#39;Eay&#39;, &#39;Eaz&#39;, &#39;Ebx&#39;,
            &#39;Eby&#39;, &#39;Ebz&#39;, &#39;Ecx&#39;, &#39;Ecy&#39;, &#39;Ecz&#39;, &#39;ovdens&#39;, &#39;nbins&#39;, &#39;fMhires&#39;,
            &#39;Ekin&#39;, &#39;Epot&#39;, &#39;SurfP&#39;, &#39;Phi0&#39;, &#39;cNFW&#39;, &#39;n_gas&#39;, &#39;M_gas&#39;,
            &#39;lambda_gas&#39;, &#39;lambdaE_gas&#39;, &#39;Lx_gas&#39;, &#39;Ly_gas&#39;, &#39;Lz_gas&#39;, &#39;b_gas&#39;,
            &#39;c_gas&#39;, &#39;Eax_gas&#39;, &#39;Eay_gas&#39;, &#39;Eaz_gas&#39;, &#39;Ebx_gas&#39;, &#39;Eby_gas&#39;,
            &#39;Ebz_gas&#39;, &#39;Ecx_gas&#39;, &#39;Ecy_gas&#39;, &#39;Ecz_gas&#39;, &#39;Ekin_gas&#39;, &#39;Epot_gas&#39;,
            &#39;n_star&#39;, &#39;M_star&#39;, &#39;lambda_star&#39;, &#39;lambdaE_star&#39;, &#39;Lx_star&#39;,
            &#39;Ly_star&#39;, &#39;Lz_star&#39;, &#39;b_star&#39;, &#39;c_star&#39;, &#39;Eax_star&#39;, &#39;Eay_star&#39;,
            &#39;Eaz_star&#39;, &#39;Ebx_star&#39;, &#39;Eby_star&#39;, &#39;Ebz_star&#39;, &#39;Ecx_star&#39;,
            &#39;Ecy_star&#39;, &#39;Ecz_star&#39;, &#39;Ekin_star&#39;, &#39;Epot_star&#39;, &#39;mean_z_gas&#39;, &#39;mean_z_star&#39;]
        self.halodata = dict()
        for i in range(len(halodata_columns)):
            colName = halodata_columns[i]
            self.halodata[colName] = halodata[i]

        self.ID = halodata[0]
        self.rawhalodata = halodata
        self.profiles = np.empty((0,PROFILE_COLUMNS))
        self.z = z
        self.halodata[&#39;z&#39;] = z
        #age is in Gyr
        self.age = analysis.tfromz(z)
        self.halodata[&#39;age&#39;] = self.age
        #sigV in km/sec
        self.sigV = halodata[18]
        #Rvir,Xc,Yc,Zc in kpc/h
        self.Rvir = halodata[11]
        self.Xc = halodata[5]
        self.Yc = halodata[6]
        self.Zc = halodata[7]
        self.pos = np.array([self.Xc,self.Yc,self.Zc])
        self.halodata[&#39;pos&#39;] = self.pos

        #velocity in km/s
        self.halodata[&#39;vel&#39;] = np.array([self.halodata[&#39;VXc&#39;], self.halodata[&#39;VYc&#39;], self.halodata[&#39;VZc&#39;]])
        self.vel = self.halodata[&#39;vel&#39;]
        #mbp_offset and com_offset in kpc/h
        self.mbp_offset = halodata[14]
        self.com_offset = halodata[15]

        #energy in M_odot/h (km/sec)^2
        self.Ekin = halodata[38]
        self.Epot = halodata[39]

        #Mass of halo in M_odot/h
        self.Mvir = halodata[3]

        #virial ratio dimensionless
        self.Qvir = -self.Ekin/self.Epot
        self.halodata[&#39;Qvir&#39;] = self.Qvir

    def addProfile(self, row):
        &#34;&#34;&#34;
        Used to add profile rows to the halo object while initialising

        Parameters
        ----------
        row : array of dtype float
            The data row from .AHF_profiles

        Notes
        -----
        Profiles should be added in *increasing* order of |radius|, input will
        not be sorted.
        &#34;&#34;&#34;
        self.profiles = np.append(self.profiles,[row],axis=0)

    def getProfileQuantityDict(self):
        &#34;&#34;&#34;
        Returns a dictionary of valid profile quantity keys, mapped to bound
        methods for the relevant quantity.

        Returns
        -------
        quantityDict : dict { quantity (str) : bound method }
        &#34;&#34;&#34;
        quantityDict = {&#39;M_in_r&#39; : self.M_in_r,
                        &#39;M_in_shell&#39; : self.M_in_shell,
                        &#39;gasM_in_r&#39; : self.gasM_in_r,
                        &#39;gasM_in_shell&#39; : self.gasM_in_shell,
                        &#39;volumes&#39; : self.volumes,
                        &#39;encDens&#39; : self.encDensities,
                        &#39;locDens&#39; : self.locDensities,
                        &#39;gasEncDens&#39; : self.gasencDensities,
                        &#39;gasLocDens&#39; : self.gaslocDensities,
                        &#39;u_gas&#39; : self.intEnergies,
                        &#39;T&#39; : self.temps,
                        &#39;starM_in_r&#39; : self.starM_in_r,
                        &#39;starM_in_shell&#39; : self.starM_in_shell,
                        &#39;starEncDens&#39; : self.starencDensities,
                        &#39;starLocDens&#39; : self.starlocDensities}
        return quantityDict

    def radii(self):
        &#34;&#34;&#34;
        Returns an array containing all of the radii of the profiles.
        Units of kpc/h

        Returns
        -------
        radii : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,0]

    def M_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the total mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        M_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,2]

    def M_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the total masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        M_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.M_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def gasM_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the gas mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        gasM_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,24]

    def gasM_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the gas masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        gasM_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.gasM_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def starM_in_r(self):
        &#34;&#34;&#34;
        Returns an array containing the stellar mass enclosed as a function of
        profile radius.
        Units of Msol/h

        Returns
        -------
        starM_in_r : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,25]

    def starM_in_shell(self):
        &#34;&#34;&#34;
        Returns an array containing the stellar masses contained only within the
        (hollow) shell that each profile makes with the last profile
        Units of Msol/h

        Returns
        -------
        starM_in_shell : array of dtype float
        &#34;&#34;&#34;
        encMass = self.starM_in_r()
        shellMass = encMass - np.append([0],encMass[:-1])
        return shellMass

    def volumes(self):
        &#34;&#34;&#34;
        Returns an array containing the volumes of each spherical profile
        Units of kpc^3 / h^3

        Returns
        -------
        volumes : array of dtype float
        &#34;&#34;&#34;
        return abs((4/3)*np.pi*(self.radii()**3))

    def shellvolumes(self):
        &#34;&#34;&#34;
        Returns an array containing the volumes of each profile *shell* (ie
        the volume between the current radius and the previous radius)

        Returns
        -------
        shellvolumes : array of dtype float
        &#34;&#34;&#34;
        vols = self.volumes()
        shellvols = vols - np.append([0], vols[:-1])
        return shellvols

    def encDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed total densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.M_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def locDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local total densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.M_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes
        #return self.profiles[:,4]

    def gasencDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed gas densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.gasM_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def gaslocDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local gas densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.gasM_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes
        #return self.profiles[:,4]

    def starencDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the enclosed stellar densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        encMass = self.starM_in_r()
        volumes = self.volumes()
        return encMass/volumes

    def starlocDensities(self):
        &#34;&#34;&#34;
        Returns an array containing the local stellar densities for each
        profile.
        Units of Msol kpc^-3 h^2

        Returns
        -------
        dens : array of dtype float
        &#34;&#34;&#34;
        shellMass = self.starM_in_shell()
        volumes = self.shellvolumes()
        return shellMass/volumes

    def intEnergies(self):
        &#34;&#34;&#34;
        Returns an array containing the internal gas energy for each profile.
        Units : ?(km/s)^2? - units not clear from AHF documentation

        Returns
        -------
        IE : array of dtype float
        &#34;&#34;&#34;
        return self.profiles[:,26]

    def temps(self):
        &#34;&#34;&#34;
        Returns an array containing the temperatures of gas for each profile.
        Calculated from the gas internal energy.
        Units of K

        WARNING:
        It is currently unclear what the gas thermal energy column represents,
        and so results using this function may be highly unreliable.

        Returns
        -------
        temps : array of dtype float
        &#34;&#34;&#34;
        print(&#34;WARNING: Temperature function may be using incorrect units for calculation&#34;)
        return analysis.UtoT(self.intEnergies())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ahfhalotools.objects.Halo.M_in_r"><code class="name flex">
<span>def <span class="ident">M_in_r</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the total mass enclosed as a function of
profile radius.
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M_in_r</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def M_in_r(self):
    &#34;&#34;&#34;
    Returns an array containing the total mass enclosed as a function of
    profile radius.
    Units of Msol/h

    Returns
    -------
    M_in_r : array of dtype float
    &#34;&#34;&#34;
    return self.profiles[:,2]</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.M_in_shell"><code class="name flex">
<span>def <span class="ident">M_in_shell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the total masses contained only within the
(hollow) shell that each profile makes with the last profile
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M_in_shell</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def M_in_shell(self):
    &#34;&#34;&#34;
    Returns an array containing the total masses contained only within the
    (hollow) shell that each profile makes with the last profile
    Units of Msol/h

    Returns
    -------
    M_in_shell : array of dtype float
    &#34;&#34;&#34;
    encMass = self.M_in_r()
    shellMass = encMass - np.append([0],encMass[:-1])
    return shellMass</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.addProfile"><code class="name flex">
<span>def <span class="ident">addProfile</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to add profile rows to the halo object while initialising</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>The data row from .AHF_profiles</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Profiles should be added in <em>increasing</em> order of |radius|, input will
not be sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addProfile(self, row):
    &#34;&#34;&#34;
    Used to add profile rows to the halo object while initialising

    Parameters
    ----------
    row : array of dtype float
        The data row from .AHF_profiles

    Notes
    -----
    Profiles should be added in *increasing* order of |radius|, input will
    not be sorted.
    &#34;&#34;&#34;
    self.profiles = np.append(self.profiles,[row],axis=0)</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.encDensities"><code class="name flex">
<span>def <span class="ident">encDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the enclosed total densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the enclosed total densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    encMass = self.M_in_r()
    volumes = self.volumes()
    return encMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.gasM_in_r"><code class="name flex">
<span>def <span class="ident">gasM_in_r</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the gas mass enclosed as a function of
profile radius.
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gasM_in_r</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gasM_in_r(self):
    &#34;&#34;&#34;
    Returns an array containing the gas mass enclosed as a function of
    profile radius.
    Units of Msol/h

    Returns
    -------
    gasM_in_r : array of dtype float
    &#34;&#34;&#34;
    return self.profiles[:,24]</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.gasM_in_shell"><code class="name flex">
<span>def <span class="ident">gasM_in_shell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the gas masses contained only within the
(hollow) shell that each profile makes with the last profile
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gasM_in_shell</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gasM_in_shell(self):
    &#34;&#34;&#34;
    Returns an array containing the gas masses contained only within the
    (hollow) shell that each profile makes with the last profile
    Units of Msol/h

    Returns
    -------
    gasM_in_shell : array of dtype float
    &#34;&#34;&#34;
    encMass = self.gasM_in_r()
    shellMass = encMass - np.append([0],encMass[:-1])
    return shellMass</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.gasencDensities"><code class="name flex">
<span>def <span class="ident">gasencDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the enclosed gas densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gasencDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the enclosed gas densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    encMass = self.gasM_in_r()
    volumes = self.volumes()
    return encMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.gaslocDensities"><code class="name flex">
<span>def <span class="ident">gaslocDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the local gas densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaslocDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the local gas densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    shellMass = self.gasM_in_shell()
    volumes = self.shellvolumes()
    return shellMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.getProfileQuantityDict"><code class="name flex">
<span>def <span class="ident">getProfileQuantityDict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of valid profile quantity keys, mapped to bound
methods for the relevant quantity.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>quantityDict</code></strong> :&ensp;<code>dict { quantity (str) : bound method }</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProfileQuantityDict(self):
    &#34;&#34;&#34;
    Returns a dictionary of valid profile quantity keys, mapped to bound
    methods for the relevant quantity.

    Returns
    -------
    quantityDict : dict { quantity (str) : bound method }
    &#34;&#34;&#34;
    quantityDict = {&#39;M_in_r&#39; : self.M_in_r,
                    &#39;M_in_shell&#39; : self.M_in_shell,
                    &#39;gasM_in_r&#39; : self.gasM_in_r,
                    &#39;gasM_in_shell&#39; : self.gasM_in_shell,
                    &#39;volumes&#39; : self.volumes,
                    &#39;encDens&#39; : self.encDensities,
                    &#39;locDens&#39; : self.locDensities,
                    &#39;gasEncDens&#39; : self.gasencDensities,
                    &#39;gasLocDens&#39; : self.gaslocDensities,
                    &#39;u_gas&#39; : self.intEnergies,
                    &#39;T&#39; : self.temps,
                    &#39;starM_in_r&#39; : self.starM_in_r,
                    &#39;starM_in_shell&#39; : self.starM_in_shell,
                    &#39;starEncDens&#39; : self.starencDensities,
                    &#39;starLocDens&#39; : self.starlocDensities}
    return quantityDict</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.intEnergies"><code class="name flex">
<span>def <span class="ident">intEnergies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the internal gas energy for each profile.
Units : ?(km/s)^2? - units not clear from AHF documentation</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>IE</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intEnergies(self):
    &#34;&#34;&#34;
    Returns an array containing the internal gas energy for each profile.
    Units : ?(km/s)^2? - units not clear from AHF documentation

    Returns
    -------
    IE : array of dtype float
    &#34;&#34;&#34;
    return self.profiles[:,26]</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.locDensities"><code class="name flex">
<span>def <span class="ident">locDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the local total densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the local total densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    shellMass = self.M_in_shell()
    volumes = self.shellvolumes()
    return shellMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.radii"><code class="name flex">
<span>def <span class="ident">radii</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing all of the radii of the profiles.
Units of kpc/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>radii</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radii(self):
    &#34;&#34;&#34;
    Returns an array containing all of the radii of the profiles.
    Units of kpc/h

    Returns
    -------
    radii : array of dtype float
    &#34;&#34;&#34;
    return self.profiles[:,0]</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.shellvolumes"><code class="name flex">
<span>def <span class="ident">shellvolumes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the volumes of each profile <em>shell</em> (ie
the volume between the current radius and the previous radius)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>shellvolumes</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shellvolumes(self):
    &#34;&#34;&#34;
    Returns an array containing the volumes of each profile *shell* (ie
    the volume between the current radius and the previous radius)

    Returns
    -------
    shellvolumes : array of dtype float
    &#34;&#34;&#34;
    vols = self.volumes()
    shellvols = vols - np.append([0], vols[:-1])
    return shellvols</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.starM_in_r"><code class="name flex">
<span>def <span class="ident">starM_in_r</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the stellar mass enclosed as a function of
profile radius.
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>starM_in_r</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starM_in_r(self):
    &#34;&#34;&#34;
    Returns an array containing the stellar mass enclosed as a function of
    profile radius.
    Units of Msol/h

    Returns
    -------
    starM_in_r : array of dtype float
    &#34;&#34;&#34;
    return self.profiles[:,25]</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.starM_in_shell"><code class="name flex">
<span>def <span class="ident">starM_in_shell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the stellar masses contained only within the
(hollow) shell that each profile makes with the last profile
Units of Msol/h</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>starM_in_shell</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starM_in_shell(self):
    &#34;&#34;&#34;
    Returns an array containing the stellar masses contained only within the
    (hollow) shell that each profile makes with the last profile
    Units of Msol/h

    Returns
    -------
    starM_in_shell : array of dtype float
    &#34;&#34;&#34;
    encMass = self.starM_in_r()
    shellMass = encMass - np.append([0],encMass[:-1])
    return shellMass</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.starencDensities"><code class="name flex">
<span>def <span class="ident">starencDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the enclosed stellar densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starencDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the enclosed stellar densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    encMass = self.starM_in_r()
    volumes = self.volumes()
    return encMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.starlocDensities"><code class="name flex">
<span>def <span class="ident">starlocDensities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the local stellar densities for each
profile.
Units of Msol kpc^-3 h^2</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dens</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starlocDensities(self):
    &#34;&#34;&#34;
    Returns an array containing the local stellar densities for each
    profile.
    Units of Msol kpc^-3 h^2

    Returns
    -------
    dens : array of dtype float
    &#34;&#34;&#34;
    shellMass = self.starM_in_shell()
    volumes = self.shellvolumes()
    return shellMass/volumes</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.temps"><code class="name flex">
<span>def <span class="ident">temps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the temperatures of gas for each profile.
Calculated from the gas internal energy.
Units of K</p>
<p>WARNING:
It is currently unclear what the gas thermal energy column represents,
and so results using this function may be highly unreliable.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>temps</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temps(self):
    &#34;&#34;&#34;
    Returns an array containing the temperatures of gas for each profile.
    Calculated from the gas internal energy.
    Units of K

    WARNING:
    It is currently unclear what the gas thermal energy column represents,
    and so results using this function may be highly unreliable.

    Returns
    -------
    temps : array of dtype float
    &#34;&#34;&#34;
    print(&#34;WARNING: Temperature function may be using incorrect units for calculation&#34;)
    return analysis.UtoT(self.intEnergies())</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Halo.volumes"><code class="name flex">
<span>def <span class="ident">volumes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the volumes of each spherical profile
Units of kpc^3 / h^3</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>volumes</code></strong> :&ensp;<code>array</code> of <code>dtype float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volumes(self):
    &#34;&#34;&#34;
    Returns an array containing the volumes of each spherical profile
    Units of kpc^3 / h^3

    Returns
    -------
    volumes : array of dtype float
    &#34;&#34;&#34;
    return abs((4/3)*np.pi*(self.radii()**3))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ahfhalotools.objects.HaloLite"><code class="flex name class">
<span>class <span class="ident">HaloLite</span></span>
<span>(</span><span>encHaloRow)</span>
</code></dt>
<dd>
<div class="desc"><p>A lightweight class to store only information relevant to velocity and
position for a halo. Used in generating lists of enclosed haloes to save
space in memory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>int</code></dt>
<dd>halo ID</dd>
<dt><strong><code>hostHalo</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of host halo under AHF subhalo scheme (may be 0 if useAHFSubHalos is
False when generating enclosed halos files)</dd>
<dt><strong><code>Xc</code></strong> :&ensp;<code>float</code></dt>
<dd>x coordinate of halo in kpc/h comoving coords</dd>
<dt><strong><code>Yc</code></strong> :&ensp;<code>float</code></dt>
<dd>y coordinate of halo in kpc/h comoving coords</dd>
<dt><strong><code>Zc</code></strong> :&ensp;<code>float</code></dt>
<dd>z coordinate of halo in kpc/h comoving coords</dd>
<dt><strong><code>VXc</code></strong> :&ensp;<code>float</code></dt>
<dd>x component of peculiar/bulk velocity in km/s</dd>
<dt><strong><code>VYc</code></strong> :&ensp;<code>float</code></dt>
<dd>y component of peculiar/bulk velocity in km/s</dd>
<dt><strong><code>VZc</code></strong> :&ensp;<code>float</code></dt>
<dd>z component of peculiar/bulk velocity in km/s</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>array (Xc , Yc , Zc)</code></dt>
<dd>Array representing position. Equal to [Xc,Yc,Zc]</dd>
<dt><strong><code>vel</code></strong> :&ensp;<code>array (VXc , VYc , VZc)</code></dt>
<dd>Array representing peculiar/bulk veclotiy. Equal to [VXc,VYc,VZc]</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFile">Cluster.generateEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">Cluster.loadEnclosedHaloFile()</a></code>
<code><a title="ahfhalotools.objects.Cluster.getEnclosedHalos" href="#ahfhalotools.objects.Cluster.getEnclosedHalos">Cluster.getEnclosedHalos()</a></code></p>
<p><code>Initialises <a title="ahfhalotools.objects.HaloLite" href="#ahfhalotools.objects.HaloLite">HaloLite</a> object from row of enclosed halo data</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>encHaloRow</code></strong> :&ensp;<code>list</code></dt>
<dd>Row should be formatted as:<h1 id="id1-hosthalo2-xc3-yc4-zc5-vxc6-vyc7-vzc8">ID(1), hostHalo(2), Xc(3), Yc(4), Zc(5), VXc(6), VYc(7), VZc(8)</h1>
(As generated from Cluster.generateEnclosedHaloFile)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HaloLite:
    &#34;&#34;&#34;
    A lightweight class to store only information relevant to velocity and
    position for a halo. Used in generating lists of enclosed haloes to save
    space in memory.

    Attributes
    ----------
    ID : int
        halo ID
    hostHalo : int
        ID of host halo under AHF subhalo scheme (may be 0 if useAHFSubHalos is
        False when generating enclosed halos files)
    Xc : float
        x coordinate of halo in kpc/h comoving coords
    Yc : float
        y coordinate of halo in kpc/h comoving coords
    Zc : float
        z coordinate of halo in kpc/h comoving coords
    VXc : float
        x component of peculiar/bulk velocity in km/s
    VYc : float
        y component of peculiar/bulk velocity in km/s
    VZc : float
        z component of peculiar/bulk velocity in km/s
    pos : array (Xc , Yc , Zc)
        Array representing position. Equal to [Xc,Yc,Zc]
    vel : array (VXc , VYc , VZc)
        Array representing peculiar/bulk veclotiy. Equal to [VXc,VYc,VZc]

    See also
    --------
    Cluster.generateEnclosedHaloFile()
    Cluster.loadEnclosedHaloFile()
    Cluster.getEnclosedHalos()
    &#34;&#34;&#34;
    def __init__(self,encHaloRow):
        &#34;&#34;&#34;
        Initialises HaloLite object from row of enclosed halo data

        Parameters
        ----------
        encHaloRow : list
            Row should be formatted as:
            # ID(1), hostHalo(2), Xc(3), Yc(4), Zc(5), VXc(6), VYc(7), VZc(8)
            (As generated from Cluster.generateEnclosedHaloFile)
        &#34;&#34;&#34;
        #encHaloRow formatted as:
        # ID(1), hostHalo(2), Xc(3), Yc(4), Zc(5), VXc(6), VYc(7), VZc(8)
        self.ID = int(encHaloRow[0])
        self.hostHalo = int(encHaloRow[1])
        self.Xc = encHaloRow[2]
        self.Yc = encHaloRow[3]
        self.Zc = encHaloRow[4]
        self.VXc = encHaloRow[5]
        self.VYc = encHaloRow[6]
        self.VZc = encHaloRow[7]
        self.pos = np.array([self.Xc,self.Yc,self.Zc])
        self.vel = np.array([self.VXc,self.VYc,self.VZc])</code></pre>
</details>
</dd>
<dt id="ahfhalotools.objects.Snapshot"><code class="flex name class">
<span>class <span class="ident">Snapshot</span></span>
<span>(</span><span>snapNo, z, haloFile, profileFile, haloLimit=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information about a single snapshot of a simulation.</p>
<p>WARNING: Snapshot objects have limited functionality, and are essentially
just used to write truncated .AHF_halos and .AHF_profiles files after
specifying a haloLimit during initialisation. File truncation should however
be done by the ahfhalotools.filetools.truncateFiles() method, as that allows
for truncation of mtree and mtree_idx files.</p>
<p>Initialises the Snapshot instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>snapNo</code></strong> :&ensp;<code>int</code></dt>
<dd>The snapshot number</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The redshift of the snapshot</dd>
<dt><strong><code>haloFile</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the .AHF_halos file to read from</dd>
<dt><strong><code>profileFile</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the .AHF_profiles file to read from</dd>
<dt><strong><code>haloLimit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Sets number of halos at which file reading terminates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Snapshot:
    &#34;&#34;&#34;
    Contains information about a single snapshot of a simulation.

    WARNING: Snapshot objects have limited functionality, and are essentially
    just used to write truncated .AHF_halos and .AHF_profiles files after
    specifying a haloLimit during initialisation. File truncation should however
    be done by the ahfhalotools.filetools.truncateFiles() method, as that allows
    for truncation of mtree and mtree_idx files.
    &#34;&#34;&#34;
    def __init__(self, snapNo, z, haloFile, profileFile, haloLimit = -1):
        &#34;&#34;&#34;
        Initialises the Snapshot instance.

        Parameters
        ----------
        snapNo : int
            The snapshot number
        z : float
            The redshift of the snapshot
        haloFile : str
            The path to the .AHF_halos file to read from
        profileFile : str
            The path to the .AHF_profiles file to read from
        haloLimit : int, optional
            Sets number of halos at which file reading terminates
        &#34;&#34;&#34;
        self.snapNo = snapNo
        self.z = z
        #age in Gyr
        self.age = analysis.tfromz(z)
        self.__haloFile__ = haloFile
        self.__profileFile__ = profileFile

        &#39;&#39;&#39;--- read in from files specified ---&#39;&#39;&#39;
        if haloLimit == -1:
            halorows = np.genfromtxt(haloFile)
            profilerows = np.genfromtxt(profileFile)
        else:
            halorows = np.genfromtxt(haloFile, max_rows = haloLimit)
            if halorows.ndim == 1:
                #make sure halorows is a 2D array (happens if numHalos = 1)
                halorows = np.array([halorows])

            numProfileRows = int(halorows[:,36].sum())
            profilerows = np.genfromtxt(profileFile, max_rows = numProfileRows)

        halos = []

        profileRowCounter = 0

        for rowIndex, halorow in enumerate(halorows):

            hostHalo = int(halorow[1])
            nbins = int(halorow[36])
            #if ((hostHalo % 1000000000000) &gt; haloLimit or hostHalo == 0) and\
            #    rowIndex &gt;= haloLimit:
            #    #halo is not a subhalo of a halo of interest, nor is a halo
            #    # of interest itself, so skip
            #    continue

            halo = Halo(halorow,z)
            prevRadius = -float(&#39;inf&#39;)

            #read in nbins lines from profiles file if halo is one of first
            # haloLimit halos
            if rowIndex &lt; haloLimit:
                for i in range(nbins):
                    assert(not (profilerows[profileRowCounter,0] &lt;= 0 and prevRadius &gt; 0))
                    #profile row is still for same halo
                    halo.addProfile(profilerows[profileRowCounter])

                    prevRadius = profilerows[profileRowCounter,0]
                    profileRowCounter += 1

            #loop has broken because next row to consider is for next halo

            halos.append(halo)

            if len(halos) == haloLimit:
                break

        self.halos = halos

    def writeFiles(self, filenamebase):
        &#34;&#34;&#34;
        Writes data saved in snapshot instance into new files with names
        filenamebase.AHF_halos and filenamebase.AHF_profiles

        Parameters
        ----------
        filenamebase : str
            The base name (including path) of the files to be outputted.
            Extensions will be added by the method.

        Notes
        -----
        This method can be used to truncate AHF_halos and AHF_profiles file in
        conjunction with setting a haloLimit during initialisation of the
        instance. File truncation should however be done using the
        ahfhalotools.filetools.truncateFiles() method.
        &#34;&#34;&#34;
        profileRows = []
        haloRows = []
        for halo in self.halos:
            haloRows.append(halo.rawhalodata)
            for profile in halo.profiles:
                profileRows.append(profile)
        np.savetxt(filenamebase+&#34;.AHF_profiles&#34;,profileRows)
        np.savetxt(filenamebase+&#34;.AHF_halos&#34;,haloRows)

    @staticmethod
    def loadFiles(snapNos,zs,filebase,profileExt=&#34;.AHF_profiles&#34;,haloExt=&#34;.AHF_halos&#34;,haloLimit=-1):
        &#34;&#34;&#34;
        Loads an array of snapshot instances from a file name format and a list
        of snap numbers and redshifts.

        Parameters
        ----------
        snapNos : list of int
            The snapshot numbers to load
        zs : list of float
            The redshifts corresponding to the snapshot numbers in snapNos
        filebase : str
            The format of the base file name. Should be formatted as such:
            &#34;GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}&#34;
            {snap:0=3d} is replaced with the snapshot number, including leading
            zeroes if number is less than 3 digits.
            z:.3f is replaces with the redshift, to three decimal places.
            Extensions are added on by the method
        profileExt : str, default = &#34;.AHF_profiles&#34;
            The file extension for the AHF_profiles files
        haloExt : str, default = &#34;.AHF_halos&#34;
            The file extension for the AHF_halos files
        haloLimit : int , optional
            The maximum number of halos to read before file reading stops.

        Returns
        -------
        snaps : array of dtype Snapshot
            An array of Snapshot objects corresponding to each of the snapshots
            specified in snapNos and zs parameters.
        &#34;&#34;&#34;
        snaps = []
        noFiles = len(zs)
        for i in range(noFiles):
            snaps.append(Snapshot(snapNos[i],zs[i], filebase.format(snap=snapNos[i],z=zs[i])+haloExt,
                                  filebase.format(snap=snapNos[i],z=zs[i])+profileExt,
                                  haloLimit = haloLimit))
            #print(&#34;Loading: {0}%&#34;.format(i/noFiles * 100))
        return np.array(snaps)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ahfhalotools.objects.Snapshot.loadFiles"><code class="name flex">
<span>def <span class="ident">loadFiles</span></span>(<span>snapNos, zs, filebase, profileExt='.AHF_profiles', haloExt='.AHF_halos', haloLimit=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an array of snapshot instances from a file name format and a list
of snap numbers and redshifts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>snapNos</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>The snapshot numbers to load</dd>
<dt><strong><code>zs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>The redshifts corresponding to the snapshot numbers in snapNos</dd>
<dt><strong><code>filebase</code></strong> :&ensp;<code>str</code></dt>
<dd>The format of the base file name. Should be formatted as such:
"GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}"
{snap:0=3d} is replaced with the snapshot number, including leading
zeroes if number is less than 3 digits.
z:.3f is replaces with the redshift, to three decimal places.
Extensions are added on by the method</dd>
<dt><strong><code>profileExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_profiles"</code></dt>
<dd>The file extension for the AHF_profiles files</dd>
<dt><strong><code>haloExt</code></strong> :&ensp;<code>str</code>, default <code>= ".AHF_halos"</code></dt>
<dd>The file extension for the AHF_halos files</dd>
<dt><strong><code>haloLimit</code></strong> :&ensp;<code>int</code> , optional</dt>
<dd>The maximum number of halos to read before file reading stops.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>snaps</code></strong> :&ensp;<code>array</code> of <code>dtype <a title="ahfhalotools.objects.Snapshot" href="#ahfhalotools.objects.Snapshot">Snapshot</a></code></dt>
<dd>An array of Snapshot objects corresponding to each of the snapshots
specified in snapNos and zs parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def loadFiles(snapNos,zs,filebase,profileExt=&#34;.AHF_profiles&#34;,haloExt=&#34;.AHF_halos&#34;,haloLimit=-1):
    &#34;&#34;&#34;
    Loads an array of snapshot instances from a file name format and a list
    of snap numbers and redshifts.

    Parameters
    ----------
    snapNos : list of int
        The snapshot numbers to load
    zs : list of float
        The redshifts corresponding to the snapshot numbers in snapNos
    filebase : str
        The format of the base file name. Should be formatted as such:
        &#34;GIZMO-NewMDCLUSTER_0001.snap_{snap:0=3d}.z{z:.3f}&#34;
        {snap:0=3d} is replaced with the snapshot number, including leading
        zeroes if number is less than 3 digits.
        z:.3f is replaces with the redshift, to three decimal places.
        Extensions are added on by the method
    profileExt : str, default = &#34;.AHF_profiles&#34;
        The file extension for the AHF_profiles files
    haloExt : str, default = &#34;.AHF_halos&#34;
        The file extension for the AHF_halos files
    haloLimit : int , optional
        The maximum number of halos to read before file reading stops.

    Returns
    -------
    snaps : array of dtype Snapshot
        An array of Snapshot objects corresponding to each of the snapshots
        specified in snapNos and zs parameters.
    &#34;&#34;&#34;
    snaps = []
    noFiles = len(zs)
    for i in range(noFiles):
        snaps.append(Snapshot(snapNos[i],zs[i], filebase.format(snap=snapNos[i],z=zs[i])+haloExt,
                              filebase.format(snap=snapNos[i],z=zs[i])+profileExt,
                              haloLimit = haloLimit))
        #print(&#34;Loading: {0}%&#34;.format(i/noFiles * 100))
    return np.array(snaps)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ahfhalotools.objects.Snapshot.writeFiles"><code class="name flex">
<span>def <span class="ident">writeFiles</span></span>(<span>self, filenamebase)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes data saved in snapshot instance into new files with names
filenamebase.AHF_halos and filenamebase.AHF_profiles</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenamebase</code></strong> :&ensp;<code>str</code></dt>
<dd>The base name (including path) of the files to be outputted.
Extensions will be added by the method.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This method can be used to truncate AHF_halos and AHF_profiles file in
conjunction with setting a haloLimit during initialisation of the
instance. File truncation should however be done using the
ahfhalotools.filetools.truncateFiles() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeFiles(self, filenamebase):
    &#34;&#34;&#34;
    Writes data saved in snapshot instance into new files with names
    filenamebase.AHF_halos and filenamebase.AHF_profiles

    Parameters
    ----------
    filenamebase : str
        The base name (including path) of the files to be outputted.
        Extensions will be added by the method.

    Notes
    -----
    This method can be used to truncate AHF_halos and AHF_profiles file in
    conjunction with setting a haloLimit during initialisation of the
    instance. File truncation should however be done using the
    ahfhalotools.filetools.truncateFiles() method.
    &#34;&#34;&#34;
    profileRows = []
    haloRows = []
    for halo in self.halos:
        haloRows.append(halo.rawhalodata)
        for profile in halo.profiles:
            profileRows.append(profile)
    np.savetxt(filenamebase+&#34;.AHF_profiles&#34;,profileRows)
    np.savetxt(filenamebase+&#34;.AHF_halos&#34;,haloRows)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ahfhalotools" href="index.html">ahfhalotools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="ahfhalotools.objects.PROFILE_COLUMNS" href="#ahfhalotools.objects.PROFILE_COLUMNS">PROFILE_COLUMNS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ahfhalotools.objects.Cluster" href="#ahfhalotools.objects.Cluster">Cluster</a></code></h4>
<ul class="">
<li><code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaHaloData">funcOfAgeDeltaHaloData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeDeltaProfileData">funcOfAgeDeltaProfileData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfAgeHaloData" href="#ahfhalotools.objects.Cluster.funcOfAgeHaloData">funcOfAgeHaloData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfAgeProfileData" href="#ahfhalotools.objects.Cluster.funcOfAgeProfileData">funcOfAgeProfileData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfRadiusProfileData" href="#ahfhalotools.objects.Cluster.funcOfRadiusProfileData">funcOfRadiusProfileData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfRandZProfileDataPoints" href="#ahfhalotools.objects.Cluster.funcOfRandZProfileDataPoints">funcOfRandZProfileDataPoints</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaHaloData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaHaloData">funcOfZDeltaHaloData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfZDeltaProfileData" href="#ahfhalotools.objects.Cluster.funcOfZDeltaProfileData">funcOfZDeltaProfileData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfZHaloData" href="#ahfhalotools.objects.Cluster.funcOfZHaloData">funcOfZHaloData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.funcOfZProfileData" href="#ahfhalotools.objects.Cluster.funcOfZProfileData">funcOfZProfileData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFile">generateEnclosedHaloFile</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.generateEnclosedHaloFilesFromChain">generateEnclosedHaloFilesFromChain</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.genpColorMeshRelSpeedEncHalos" href="#ahfhalotools.objects.Cluster.genpColorMeshRelSpeedEncHalos">genpColorMeshRelSpeedEncHalos</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getEnclosedHalos" href="#ahfhalotools.objects.Cluster.getEnclosedHalos">getEnclosedHalos</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getFatherOf" href="#ahfhalotools.objects.Cluster.getFatherOf">getFatherOf</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getHalo" href="#ahfhalotools.objects.Cluster.getHalo">getHalo</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getHaloData" href="#ahfhalotools.objects.Cluster.getHaloData">getHaloData</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getLargestMergeZInRange" href="#ahfhalotools.objects.Cluster.getLargestMergeZInRange">getLargestMergeZInRange</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getMergeSize" href="#ahfhalotools.objects.Cluster.getMergeSize">getMergeSize</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getMergeTimes" href="#ahfhalotools.objects.Cluster.getMergeTimes">getMergeTimes</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getMergeTreeEntry" href="#ahfhalotools.objects.Cluster.getMergeTreeEntry">getMergeTreeEntry</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getMergeZs" href="#ahfhalotools.objects.Cluster.getMergeZs">getMergeZs</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelSpeedsOfEncHalos">getRelSpeedsOfEncHalos</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos" href="#ahfhalotools.objects.Cluster.getRelVelocitiesOfEncHalos">getRelVelocitiesOfEncHalos</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFile" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFile">loadEnclosedHaloFile</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain" href="#ahfhalotools.objects.Cluster.loadEnclosedHaloFilesFromChain">loadEnclosedHaloFilesFromChain</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.trackHalo" href="#ahfhalotools.objects.Cluster.trackHalo">trackHalo</a></code></li>
<li><code><a title="ahfhalotools.objects.Cluster.trackID" href="#ahfhalotools.objects.Cluster.trackID">trackID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ahfhalotools.objects.Halo" href="#ahfhalotools.objects.Halo">Halo</a></code></h4>
<ul class="">
<li><code><a title="ahfhalotools.objects.Halo.M_in_r" href="#ahfhalotools.objects.Halo.M_in_r">M_in_r</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.M_in_shell" href="#ahfhalotools.objects.Halo.M_in_shell">M_in_shell</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.addProfile" href="#ahfhalotools.objects.Halo.addProfile">addProfile</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.encDensities" href="#ahfhalotools.objects.Halo.encDensities">encDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.gasM_in_r" href="#ahfhalotools.objects.Halo.gasM_in_r">gasM_in_r</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.gasM_in_shell" href="#ahfhalotools.objects.Halo.gasM_in_shell">gasM_in_shell</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.gasencDensities" href="#ahfhalotools.objects.Halo.gasencDensities">gasencDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.gaslocDensities" href="#ahfhalotools.objects.Halo.gaslocDensities">gaslocDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.getProfileQuantityDict" href="#ahfhalotools.objects.Halo.getProfileQuantityDict">getProfileQuantityDict</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.intEnergies" href="#ahfhalotools.objects.Halo.intEnergies">intEnergies</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.locDensities" href="#ahfhalotools.objects.Halo.locDensities">locDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.radii" href="#ahfhalotools.objects.Halo.radii">radii</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.shellvolumes" href="#ahfhalotools.objects.Halo.shellvolumes">shellvolumes</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.starM_in_r" href="#ahfhalotools.objects.Halo.starM_in_r">starM_in_r</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.starM_in_shell" href="#ahfhalotools.objects.Halo.starM_in_shell">starM_in_shell</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.starencDensities" href="#ahfhalotools.objects.Halo.starencDensities">starencDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.starlocDensities" href="#ahfhalotools.objects.Halo.starlocDensities">starlocDensities</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.temps" href="#ahfhalotools.objects.Halo.temps">temps</a></code></li>
<li><code><a title="ahfhalotools.objects.Halo.volumes" href="#ahfhalotools.objects.Halo.volumes">volumes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ahfhalotools.objects.HaloLite" href="#ahfhalotools.objects.HaloLite">HaloLite</a></code></h4>
</li>
<li>
<h4><code><a title="ahfhalotools.objects.Snapshot" href="#ahfhalotools.objects.Snapshot">Snapshot</a></code></h4>
<ul class="">
<li><code><a title="ahfhalotools.objects.Snapshot.loadFiles" href="#ahfhalotools.objects.Snapshot.loadFiles">loadFiles</a></code></li>
<li><code><a title="ahfhalotools.objects.Snapshot.writeFiles" href="#ahfhalotools.objects.Snapshot.writeFiles">writeFiles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>